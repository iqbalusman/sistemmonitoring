{
  "version": 3,
  "sources": ["../../@supabase/postgrest-js/src/PostgrestError.ts", "../../@supabase/postgrest-js/src/PostgrestBuilder.ts", "../../@supabase/postgrest-js/src/PostgrestTransformBuilder.ts", "../../@supabase/postgrest-js/src/PostgrestFilterBuilder.ts", "../../@supabase/postgrest-js/src/PostgrestQueryBuilder.ts", "../../@supabase/postgrest-js/src/PostgrestClient.ts", "../../@supabase/postgrest-js/src/index.ts", "../../@supabase/functions-js/src/helper.ts", "../../@supabase/functions-js/src/types.ts", "../../@supabase/functions-js/src/FunctionsClient.ts", "../../@supabase/postgrest-js/dist/esm/wrapper.mjs", "../../isows/utils.ts", "../../isows/native.ts", "../../@supabase/realtime-js/src/lib/version.ts", "../../@supabase/realtime-js/src/lib/constants.ts", "../../@supabase/realtime-js/src/lib/serializer.ts", "../../@supabase/realtime-js/src/lib/timer.ts", "../../@supabase/realtime-js/src/lib/transformers.ts", "../../@supabase/realtime-js/src/lib/push.ts", "../../@supabase/realtime-js/src/RealtimePresence.ts", "../../@supabase/realtime-js/src/RealtimeChannel.ts", "../../@supabase/realtime-js/src/RealtimeClient.ts", "../../@supabase/storage-js/src/lib/errors.ts", "../../@supabase/storage-js/src/lib/helpers.ts", "../../@supabase/storage-js/src/lib/fetch.ts", "../../@supabase/storage-js/src/packages/StorageFileApi.ts", "../../@supabase/storage-js/src/lib/version.ts", "../../@supabase/storage-js/src/lib/constants.ts", "../../@supabase/storage-js/src/packages/StorageBucketApi.ts", "../../@supabase/storage-js/src/StorageClient.ts", "../../@supabase/supabase-js/src/lib/version.ts", "../../@supabase/supabase-js/src/lib/constants.ts", "../../@supabase/supabase-js/src/lib/fetch.ts", "../../@supabase/supabase-js/src/lib/helpers.ts", "../../@supabase/supabase-js/src/SupabaseClient.ts", "../../@supabase/supabase-js/src/index.ts"],
  "sourcesContent": ["/**\n * Error format\n *\n * {@link https://postgrest.org/en/stable/api.html?highlight=options#errors-and-http-status-codes}\n */\nexport default class PostgrestError extends Error {\n  details: string\n  hint: string\n  code: string\n\n  constructor(context: { message: string; details: string; hint: string; code: string }) {\n    super(context.message)\n    this.name = 'PostgrestError'\n    this.details = context.details\n    this.hint = context.hint\n    this.code = context.code\n  }\n}\n", "// @ts-ignore\nimport nodeFetch from '@supabase/node-fetch'\n\nimport type {\n  Fetch,\n  PostgrestSingleResponse,\n  PostgrestResponseSuccess,\n  CheckMatchingArrayTypes,\n  MergePartialResult,\n  IsValidResultOverride,\n  ClientServerOptions,\n} from './types'\nimport PostgrestError from './PostgrestError'\nimport { ContainsNull } from './select-query-parser/types'\n\nexport default abstract class PostgrestBuilder<\n  ClientOptions extends ClientServerOptions,\n  Result,\n  ThrowOnError extends boolean = false\n> implements\n    PromiseLike<\n      ThrowOnError extends true ? PostgrestResponseSuccess<Result> : PostgrestSingleResponse<Result>\n    >\n{\n  protected method: 'GET' | 'HEAD' | 'POST' | 'PATCH' | 'DELETE'\n  protected url: URL\n  protected headers: Headers\n  protected schema?: string\n  protected body?: unknown\n  protected shouldThrowOnError = false\n  protected signal?: AbortSignal\n  protected fetch: Fetch\n  protected isMaybeSingle: boolean\n\n  constructor(builder: {\n    method: 'GET' | 'HEAD' | 'POST' | 'PATCH' | 'DELETE'\n    url: URL\n    headers: HeadersInit\n    schema?: string\n    body?: unknown\n    shouldThrowOnError?: boolean\n    signal?: AbortSignal\n    fetch?: Fetch\n    isMaybeSingle?: boolean\n  }) {\n    this.method = builder.method\n    this.url = builder.url\n    this.headers = new Headers(builder.headers)\n    this.schema = builder.schema\n    this.body = builder.body\n    this.shouldThrowOnError = builder.shouldThrowOnError ?? false\n    this.signal = builder.signal\n    this.isMaybeSingle = builder.isMaybeSingle ?? false\n\n    if (builder.fetch) {\n      this.fetch = builder.fetch\n    } else if (typeof fetch === 'undefined') {\n      this.fetch = nodeFetch\n    } else {\n      this.fetch = fetch\n    }\n  }\n\n  /**\n   * If there's an error with the query, throwOnError will reject the promise by\n   * throwing the error instead of returning it as part of a successful response.\n   *\n   * {@link https://github.com/supabase/supabase-js/issues/92}\n   */\n  throwOnError(): this & PostgrestBuilder<ClientOptions, Result, true> {\n    this.shouldThrowOnError = true\n    return this as this & PostgrestBuilder<ClientOptions, Result, true>\n  }\n\n  /**\n   * Set an HTTP header for the request.\n   */\n  setHeader(name: string, value: string): this {\n    this.headers = new Headers(this.headers)\n    this.headers.set(name, value)\n    return this\n  }\n\n  then<\n    TResult1 = ThrowOnError extends true\n      ? PostgrestResponseSuccess<Result>\n      : PostgrestSingleResponse<Result>,\n    TResult2 = never\n  >(\n    onfulfilled?:\n      | ((\n          value: ThrowOnError extends true\n            ? PostgrestResponseSuccess<Result>\n            : PostgrestSingleResponse<Result>\n        ) => TResult1 | PromiseLike<TResult1>)\n      | undefined\n      | null,\n    onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null\n  ): PromiseLike<TResult1 | TResult2> {\n    // https://postgrest.org/en/stable/api.html#switching-schemas\n    if (this.schema === undefined) {\n      // skip\n    } else if (['GET', 'HEAD'].includes(this.method)) {\n      this.headers.set('Accept-Profile', this.schema)\n    } else {\n      this.headers.set('Content-Profile', this.schema)\n    }\n    if (this.method !== 'GET' && this.method !== 'HEAD') {\n      this.headers.set('Content-Type', 'application/json')\n    }\n\n    // NOTE: Invoke w/o `this` to avoid illegal invocation error.\n    // https://github.com/supabase/postgrest-js/pull/247\n    const _fetch = this.fetch\n    let res = _fetch(this.url.toString(), {\n      method: this.method,\n      headers: this.headers,\n      body: JSON.stringify(this.body),\n      signal: this.signal,\n    }).then(async (res) => {\n      let error = null\n      let data = null\n      let count: number | null = null\n      let status = res.status\n      let statusText = res.statusText\n\n      if (res.ok) {\n        if (this.method !== 'HEAD') {\n          const body = await res.text()\n          if (body === '') {\n            // Prefer: return=minimal\n          } else if (this.headers.get('Accept') === 'text/csv') {\n            data = body\n          } else if (\n            this.headers.get('Accept') &&\n            this.headers.get('Accept')?.includes('application/vnd.pgrst.plan+text')\n          ) {\n            data = body\n          } else {\n            data = JSON.parse(body)\n          }\n        }\n\n        const countHeader = this.headers.get('Prefer')?.match(/count=(exact|planned|estimated)/)\n        const contentRange = res.headers.get('content-range')?.split('/')\n        if (countHeader && contentRange && contentRange.length > 1) {\n          count = parseInt(contentRange[1])\n        }\n\n        // Temporary partial fix for https://github.com/supabase/postgrest-js/issues/361\n        // Issue persists e.g. for `.insert([...]).select().maybeSingle()`\n        if (this.isMaybeSingle && this.method === 'GET' && Array.isArray(data)) {\n          if (data.length > 1) {\n            error = {\n              // https://github.com/PostgREST/postgrest/blob/a867d79c42419af16c18c3fb019eba8df992626f/src/PostgREST/Error.hs#L553\n              code: 'PGRST116',\n              details: `Results contain ${data.length} rows, application/vnd.pgrst.object+json requires 1 row`,\n              hint: null,\n              message: 'JSON object requested, multiple (or no) rows returned',\n            }\n            data = null\n            count = null\n            status = 406\n            statusText = 'Not Acceptable'\n          } else if (data.length === 1) {\n            data = data[0]\n          } else {\n            data = null\n          }\n        }\n      } else {\n        const body = await res.text()\n\n        try {\n          error = JSON.parse(body)\n\n          // Workaround for https://github.com/supabase/postgrest-js/issues/295\n          if (Array.isArray(error) && res.status === 404) {\n            data = []\n            error = null\n            status = 200\n            statusText = 'OK'\n          }\n        } catch {\n          // Workaround for https://github.com/supabase/postgrest-js/issues/295\n          if (res.status === 404 && body === '') {\n            status = 204\n            statusText = 'No Content'\n          } else {\n            error = {\n              message: body,\n            }\n          }\n        }\n\n        if (error && this.isMaybeSingle && error?.details?.includes('0 rows')) {\n          error = null\n          status = 200\n          statusText = 'OK'\n        }\n\n        if (error && this.shouldThrowOnError) {\n          throw new PostgrestError(error)\n        }\n      }\n\n      const postgrestResponse = {\n        error,\n        data,\n        count,\n        status,\n        statusText,\n      }\n\n      return postgrestResponse\n    })\n    if (!this.shouldThrowOnError) {\n      res = res.catch((fetchError) => ({\n        error: {\n          message: `${fetchError?.name ?? 'FetchError'}: ${fetchError?.message}`,\n          details: `${fetchError?.stack ?? ''}`,\n          hint: '',\n          code: `${fetchError?.code ?? ''}`,\n        },\n        data: null,\n        count: null,\n        status: 0,\n        statusText: '',\n      }))\n    }\n\n    return res.then(onfulfilled, onrejected)\n  }\n\n  /**\n   * Override the type of the returned `data`.\n   *\n   * @typeParam NewResult - The new result type to override with\n   * @deprecated Use overrideTypes<yourType, { merge: false }>() method at the end of your call chain instead\n   */\n  returns<NewResult>(): PostgrestBuilder<\n    ClientOptions,\n    CheckMatchingArrayTypes<Result, NewResult>,\n    ThrowOnError\n  > {\n    /* istanbul ignore next */\n    return this as unknown as PostgrestBuilder<\n      ClientOptions,\n      CheckMatchingArrayTypes<Result, NewResult>,\n      ThrowOnError\n    >\n  }\n\n  /**\n   * Override the type of the returned `data` field in the response.\n   *\n   * @typeParam NewResult - The new type to cast the response data to\n   * @typeParam Options - Optional type configuration (defaults to { merge: true })\n   * @typeParam Options.merge - When true, merges the new type with existing return type. When false, replaces the existing types entirely (defaults to true)\n   * @example\n   * ```typescript\n   * // Merge with existing types (default behavior)\n   * const query = supabase\n   *   .from('users')\n   *   .select()\n   *   .overrideTypes<{ custom_field: string }>()\n   *\n   * // Replace existing types completely\n   * const replaceQuery = supabase\n   *   .from('users')\n   *   .select()\n   *   .overrideTypes<{ id: number; name: string }, { merge: false }>()\n   * ```\n   * @returns A PostgrestBuilder instance with the new type\n   */\n  overrideTypes<\n    NewResult,\n    Options extends { merge?: boolean } = { merge: true }\n  >(): PostgrestBuilder<\n    ClientOptions,\n    IsValidResultOverride<Result, NewResult, false, false> extends true\n      ? // Preserve the optionality of the result if the overriden type is an object (case of chaining with `maybeSingle`)\n        ContainsNull<Result> extends true\n        ? MergePartialResult<NewResult, NonNullable<Result>, Options> | null\n        : MergePartialResult<NewResult, Result, Options>\n      : CheckMatchingArrayTypes<Result, NewResult>,\n    ThrowOnError\n  > {\n    return this as unknown as PostgrestBuilder<\n      ClientOptions,\n      IsValidResultOverride<Result, NewResult, false, false> extends true\n        ? // Preserve the optionality of the result if the overriden type is an object (case of chaining with `maybeSingle`)\n          ContainsNull<Result> extends true\n          ? MergePartialResult<NewResult, NonNullable<Result>, Options> | null\n          : MergePartialResult<NewResult, Result, Options>\n        : CheckMatchingArrayTypes<Result, NewResult>,\n      ThrowOnError\n    >\n  }\n}\n", "import PostgrestBuilder from './PostgrestBuilder'\nimport { InvalidMethodError } from './PostgrestFilterBuilder'\nimport { GetResult } from './select-query-parser/result'\nimport {\n  GenericSchema,\n  CheckMatchingArrayTypes,\n  ClientServerOptions,\n  MaxAffectedEnabled,\n} from './types'\n\nexport default class PostgrestTransformBuilder<\n  ClientOptions extends ClientServerOptions,\n  Schema extends GenericSchema,\n  Row extends Record<string, unknown>,\n  Result,\n  RelationName = unknown,\n  Relationships = unknown,\n  Method = unknown\n> extends PostgrestBuilder<ClientOptions, Result> {\n  /**\n   * Perform a SELECT on the query result.\n   *\n   * By default, `.insert()`, `.update()`, `.upsert()`, and `.delete()` do not\n   * return modified rows. By calling this method, modified rows are returned in\n   * `data`.\n   *\n   * @param columns - The columns to retrieve, separated by commas\n   */\n  select<\n    Query extends string = '*',\n    NewResultOne = GetResult<Schema, Row, RelationName, Relationships, Query, ClientOptions>\n  >(\n    columns?: Query\n  ): PostgrestTransformBuilder<\n    ClientOptions,\n    Schema,\n    Row,\n    NewResultOne[],\n    RelationName,\n    Relationships,\n    Method\n  > {\n    // Remove whitespaces except when quoted\n    let quoted = false\n    const cleanedColumns = (columns ?? '*')\n      .split('')\n      .map((c) => {\n        if (/\\s/.test(c) && !quoted) {\n          return ''\n        }\n        if (c === '\"') {\n          quoted = !quoted\n        }\n        return c\n      })\n      .join('')\n    this.url.searchParams.set('select', cleanedColumns)\n    this.headers.append('Prefer', 'return=representation')\n    return this as unknown as PostgrestTransformBuilder<\n      ClientOptions,\n      Schema,\n      Row,\n      NewResultOne[],\n      RelationName,\n      Relationships,\n      Method\n    >\n  }\n\n  order<ColumnName extends string & keyof Row>(\n    column: ColumnName,\n    options?: { ascending?: boolean; nullsFirst?: boolean; referencedTable?: undefined }\n  ): this\n  order(\n    column: string,\n    options?: { ascending?: boolean; nullsFirst?: boolean; referencedTable?: string }\n  ): this\n  /**\n   * @deprecated Use `options.referencedTable` instead of `options.foreignTable`\n   */\n  order<ColumnName extends string & keyof Row>(\n    column: ColumnName,\n    options?: { ascending?: boolean; nullsFirst?: boolean; foreignTable?: undefined }\n  ): this\n  /**\n   * @deprecated Use `options.referencedTable` instead of `options.foreignTable`\n   */\n  order(\n    column: string,\n    options?: { ascending?: boolean; nullsFirst?: boolean; foreignTable?: string }\n  ): this\n  /**\n   * Order the query result by `column`.\n   *\n   * You can call this method multiple times to order by multiple columns.\n   *\n   * You can order referenced tables, but it only affects the ordering of the\n   * parent table if you use `!inner` in the query.\n   *\n   * @param column - The column to order by\n   * @param options - Named parameters\n   * @param options.ascending - If `true`, the result will be in ascending order\n   * @param options.nullsFirst - If `true`, `null`s appear first. If `false`,\n   * `null`s appear last.\n   * @param options.referencedTable - Set this to order a referenced table by\n   * its columns\n   * @param options.foreignTable - Deprecated, use `options.referencedTable`\n   * instead\n   */\n  order(\n    column: string,\n    {\n      ascending = true,\n      nullsFirst,\n      foreignTable,\n      referencedTable = foreignTable,\n    }: {\n      ascending?: boolean\n      nullsFirst?: boolean\n      foreignTable?: string\n      referencedTable?: string\n    } = {}\n  ): this {\n    const key = referencedTable ? `${referencedTable}.order` : 'order'\n    const existingOrder = this.url.searchParams.get(key)\n\n    this.url.searchParams.set(\n      key,\n      `${existingOrder ? `${existingOrder},` : ''}${column}.${ascending ? 'asc' : 'desc'}${\n        nullsFirst === undefined ? '' : nullsFirst ? '.nullsfirst' : '.nullslast'\n      }`\n    )\n    return this\n  }\n\n  /**\n   * Limit the query result by `count`.\n   *\n   * @param count - The maximum number of rows to return\n   * @param options - Named parameters\n   * @param options.referencedTable - Set this to limit rows of referenced\n   * tables instead of the parent table\n   * @param options.foreignTable - Deprecated, use `options.referencedTable`\n   * instead\n   */\n  limit(\n    count: number,\n    {\n      foreignTable,\n      referencedTable = foreignTable,\n    }: { foreignTable?: string; referencedTable?: string } = {}\n  ): this {\n    const key = typeof referencedTable === 'undefined' ? 'limit' : `${referencedTable}.limit`\n    this.url.searchParams.set(key, `${count}`)\n    return this\n  }\n\n  /**\n   * Limit the query result by starting at an offset `from` and ending at the offset `to`.\n   * Only records within this range are returned.\n   * This respects the query order and if there is no order clause the range could behave unexpectedly.\n   * The `from` and `to` values are 0-based and inclusive: `range(1, 3)` will include the second, third\n   * and fourth rows of the query.\n   *\n   * @param from - The starting index from which to limit the result\n   * @param to - The last index to which to limit the result\n   * @param options - Named parameters\n   * @param options.referencedTable - Set this to limit rows of referenced\n   * tables instead of the parent table\n   * @param options.foreignTable - Deprecated, use `options.referencedTable`\n   * instead\n   */\n  range(\n    from: number,\n    to: number,\n    {\n      foreignTable,\n      referencedTable = foreignTable,\n    }: { foreignTable?: string; referencedTable?: string } = {}\n  ): this {\n    const keyOffset =\n      typeof referencedTable === 'undefined' ? 'offset' : `${referencedTable}.offset`\n    const keyLimit = typeof referencedTable === 'undefined' ? 'limit' : `${referencedTable}.limit`\n    this.url.searchParams.set(keyOffset, `${from}`)\n    // Range is inclusive, so add 1\n    this.url.searchParams.set(keyLimit, `${to - from + 1}`)\n    return this\n  }\n\n  /**\n   * Set the AbortSignal for the fetch request.\n   *\n   * @param signal - The AbortSignal to use for the fetch request\n   */\n  abortSignal(signal: AbortSignal): this {\n    this.signal = signal\n    return this\n  }\n\n  /**\n   * Return `data` as a single object instead of an array of objects.\n   *\n   * Query result must be one row (e.g. using `.limit(1)`), otherwise this\n   * returns an error.\n   */\n  single<ResultOne = Result extends (infer ResultOne)[] ? ResultOne : never>(): PostgrestBuilder<\n    ClientOptions,\n    ResultOne\n  > {\n    this.headers.set('Accept', 'application/vnd.pgrst.object+json')\n    return this as unknown as PostgrestBuilder<ClientOptions, ResultOne>\n  }\n\n  /**\n   * Return `data` as a single object instead of an array of objects.\n   *\n   * Query result must be zero or one row (e.g. using `.limit(1)`), otherwise\n   * this returns an error.\n   */\n  maybeSingle<\n    ResultOne = Result extends (infer ResultOne)[] ? ResultOne : never\n  >(): PostgrestBuilder<ClientOptions, ResultOne | null> {\n    // Temporary partial fix for https://github.com/supabase/postgrest-js/issues/361\n    // Issue persists e.g. for `.insert([...]).select().maybeSingle()`\n    if (this.method === 'GET') {\n      this.headers.set('Accept', 'application/json')\n    } else {\n      this.headers.set('Accept', 'application/vnd.pgrst.object+json')\n    }\n    this.isMaybeSingle = true\n    return this as unknown as PostgrestBuilder<ClientOptions, ResultOne | null>\n  }\n\n  /**\n   * Return `data` as a string in CSV format.\n   */\n  csv(): PostgrestBuilder<ClientOptions, string> {\n    this.headers.set('Accept', 'text/csv')\n    return this as unknown as PostgrestBuilder<ClientOptions, string>\n  }\n\n  /**\n   * Return `data` as an object in [GeoJSON](https://geojson.org) format.\n   */\n  geojson(): PostgrestBuilder<ClientOptions, Record<string, unknown>> {\n    this.headers.set('Accept', 'application/geo+json')\n    return this as unknown as PostgrestBuilder<ClientOptions, Record<string, unknown>>\n  }\n\n  /**\n   * Return `data` as the EXPLAIN plan for the query.\n   *\n   * You need to enable the\n   * [db_plan_enabled](https://supabase.com/docs/guides/database/debugging-performance#enabling-explain)\n   * setting before using this method.\n   *\n   * @param options - Named parameters\n   *\n   * @param options.analyze - If `true`, the query will be executed and the\n   * actual run time will be returned\n   *\n   * @param options.verbose - If `true`, the query identifier will be returned\n   * and `data` will include the output columns of the query\n   *\n   * @param options.settings - If `true`, include information on configuration\n   * parameters that affect query planning\n   *\n   * @param options.buffers - If `true`, include information on buffer usage\n   *\n   * @param options.wal - If `true`, include information on WAL record generation\n   *\n   * @param options.format - The format of the output, can be `\"text\"` (default)\n   * or `\"json\"`\n   */\n  explain({\n    analyze = false,\n    verbose = false,\n    settings = false,\n    buffers = false,\n    wal = false,\n    format = 'text',\n  }: {\n    analyze?: boolean\n    verbose?: boolean\n    settings?: boolean\n    buffers?: boolean\n    wal?: boolean\n    format?: 'json' | 'text'\n  } = {}) {\n    const options = [\n      analyze ? 'analyze' : null,\n      verbose ? 'verbose' : null,\n      settings ? 'settings' : null,\n      buffers ? 'buffers' : null,\n      wal ? 'wal' : null,\n    ]\n      .filter(Boolean)\n      .join('|')\n    // An Accept header can carry multiple media types but postgrest-js always sends one\n    const forMediatype = this.headers.get('Accept') ?? 'application/json'\n    this.headers.set(\n      'Accept',\n      `application/vnd.pgrst.plan+${format}; for=\"${forMediatype}\"; options=${options};`\n    )\n    if (format === 'json') {\n      return this as unknown as PostgrestBuilder<ClientOptions, Record<string, unknown>[]>\n    } else {\n      return this as unknown as PostgrestBuilder<ClientOptions, string>\n    }\n  }\n\n  /**\n   * Rollback the query.\n   *\n   * `data` will still be returned, but the query is not committed.\n   */\n  rollback(): this {\n    this.headers.append('Prefer', 'tx=rollback')\n    return this\n  }\n\n  /**\n   * Override the type of the returned `data`.\n   *\n   * @typeParam NewResult - The new result type to override with\n   * @deprecated Use overrideTypes<yourType, { merge: false }>() method at the end of your call chain instead\n   */\n  returns<NewResult>(): PostgrestTransformBuilder<\n    ClientOptions,\n    Schema,\n    Row,\n    CheckMatchingArrayTypes<Result, NewResult>,\n    RelationName,\n    Relationships,\n    Method\n  > {\n    return this as unknown as PostgrestTransformBuilder<\n      ClientOptions,\n      Schema,\n      Row,\n      CheckMatchingArrayTypes<Result, NewResult>,\n      RelationName,\n      Relationships,\n      Method\n    >\n  }\n\n  /**\n   * Set the maximum number of rows that can be affected by the query.\n   * Only available in PostgREST v13+ and only works with PATCH and DELETE methods.\n   *\n   * @param value - The maximum number of rows that can be affected\n   */\n  maxAffected(value: number): MaxAffectedEnabled<ClientOptions['PostgrestVersion']> extends true\n    ? // TODO: update the RPC case to only work on RPC that returns SETOF rows\n      Method extends 'PATCH' | 'DELETE' | 'RPC'\n      ? this\n      : InvalidMethodError<'maxAffected method only available on update or delete'>\n    : InvalidMethodError<'maxAffected method only available on postgrest 13+'> {\n    this.headers.append('Prefer', 'handling=strict')\n    this.headers.append('Prefer', `max-affected=${value}`)\n    return this as unknown as MaxAffectedEnabled<ClientOptions['PostgrestVersion']> extends true\n      ? Method extends 'PATCH' | 'DELETE' | 'RPC'\n        ? this\n        : InvalidMethodError<'maxAffected method only available on update or delete'>\n      : InvalidMethodError<'maxAffected method only available on postgrest 13+'>\n  }\n}\n", "import PostgrestTransformBuilder from './PostgrestTransformBuilder'\nimport { JsonPathToAccessor, JsonPathToType } from './select-query-parser/utils'\nimport { ClientServerOptions, GenericSchema } from './types'\n\ntype FilterOperator =\n  | 'eq'\n  | 'neq'\n  | 'gt'\n  | 'gte'\n  | 'lt'\n  | 'lte'\n  | 'like'\n  | 'ilike'\n  | 'is'\n  | 'in'\n  | 'cs'\n  | 'cd'\n  | 'sl'\n  | 'sr'\n  | 'nxl'\n  | 'nxr'\n  | 'adj'\n  | 'ov'\n  | 'fts'\n  | 'plfts'\n  | 'phfts'\n  | 'wfts'\n\nexport type IsStringOperator<Path extends string> = Path extends `${string}->>${string}`\n  ? true\n  : false\n\n// Match relationship filters with `table.column` syntax and resolve underlying\n// column value. If not matched, fallback to generic type.\n// TODO: Validate the relationship itself ala select-query-parser. Currently we\n// assume that all tables have valid relationships to each other, despite\n// nonexistent foreign keys.\ntype ResolveFilterValue<\n  Schema extends GenericSchema,\n  Row extends Record<string, unknown>,\n  ColumnName extends string\n> = ColumnName extends `${infer RelationshipTable}.${infer Remainder}`\n  ? Remainder extends `${infer _}.${infer _}`\n    ? ResolveFilterValue<Schema, Row, Remainder>\n    : ResolveFilterRelationshipValue<Schema, RelationshipTable, Remainder>\n  : ColumnName extends keyof Row\n  ? Row[ColumnName]\n  : // If the column selection is a jsonpath like `data->value` or `data->>value` we attempt to match\n  // the expected type with the parsed custom json type\n  IsStringOperator<ColumnName> extends true\n  ? string\n  : JsonPathToType<Row, JsonPathToAccessor<ColumnName>> extends infer JsonPathValue\n  ? JsonPathValue extends never\n    ? never\n    : JsonPathValue\n  : never\n\ntype ResolveFilterRelationshipValue<\n  Schema extends GenericSchema,\n  RelationshipTable extends string,\n  RelationshipColumn extends string\n> = Schema['Tables'] & Schema['Views'] extends infer TablesAndViews\n  ? RelationshipTable extends keyof TablesAndViews\n    ? 'Row' extends keyof TablesAndViews[RelationshipTable]\n      ? RelationshipColumn extends keyof TablesAndViews[RelationshipTable]['Row']\n        ? TablesAndViews[RelationshipTable]['Row'][RelationshipColumn]\n        : unknown\n      : unknown\n    : unknown\n  : never\n\nexport type InvalidMethodError<S extends string> = { Error: S }\n\nexport default class PostgrestFilterBuilder<\n  ClientOptions extends ClientServerOptions,\n  Schema extends GenericSchema,\n  Row extends Record<string, unknown>,\n  Result,\n  RelationName = unknown,\n  Relationships = unknown,\n  Method = unknown\n> extends PostgrestTransformBuilder<\n  ClientOptions,\n  Schema,\n  Row,\n  Result,\n  RelationName,\n  Relationships,\n  Method\n> {\n  /**\n   * Match only rows where `column` is equal to `value`.\n   *\n   * To check if the value of `column` is NULL, you should use `.is()` instead.\n   *\n   * @param column - The column to filter on\n   * @param value - The value to filter with\n   */\n  eq<ColumnName extends string>(\n    column: ColumnName,\n    value: ResolveFilterValue<Schema, Row, ColumnName> extends never\n      ? NonNullable<unknown>\n      : // We want to infer the type before wrapping it into a `NonNullable` to avoid too deep\n      // type resolution error\n      ResolveFilterValue<Schema, Row, ColumnName> extends infer ResolvedFilterValue\n      ? NonNullable<ResolvedFilterValue>\n      : // We should never enter this case as all the branches are covered above\n        never\n  ): this {\n    this.url.searchParams.append(column, `eq.${value}`)\n    return this\n  }\n\n  /**\n   * Match only rows where `column` is not equal to `value`.\n   *\n   * @param column - The column to filter on\n   * @param value - The value to filter with\n   */\n  neq<ColumnName extends string>(\n    column: ColumnName,\n    value: ResolveFilterValue<Schema, Row, ColumnName> extends never\n      ? unknown\n      : ResolveFilterValue<Schema, Row, ColumnName> extends infer ResolvedFilterValue\n      ? ResolvedFilterValue\n      : never\n  ): this {\n    this.url.searchParams.append(column, `neq.${value}`)\n    return this\n  }\n\n  gt<ColumnName extends string & keyof Row>(column: ColumnName, value: Row[ColumnName]): this\n  gt(column: string, value: unknown): this\n  /**\n   * Match only rows where `column` is greater than `value`.\n   *\n   * @param column - The column to filter on\n   * @param value - The value to filter with\n   */\n  gt(column: string, value: unknown): this {\n    this.url.searchParams.append(column, `gt.${value}`)\n    return this\n  }\n\n  gte<ColumnName extends string & keyof Row>(column: ColumnName, value: Row[ColumnName]): this\n  gte(column: string, value: unknown): this\n  /**\n   * Match only rows where `column` is greater than or equal to `value`.\n   *\n   * @param column - The column to filter on\n   * @param value - The value to filter with\n   */\n  gte(column: string, value: unknown): this {\n    this.url.searchParams.append(column, `gte.${value}`)\n    return this\n  }\n\n  lt<ColumnName extends string & keyof Row>(column: ColumnName, value: Row[ColumnName]): this\n  lt(column: string, value: unknown): this\n  /**\n   * Match only rows where `column` is less than `value`.\n   *\n   * @param column - The column to filter on\n   * @param value - The value to filter with\n   */\n  lt(column: string, value: unknown): this {\n    this.url.searchParams.append(column, `lt.${value}`)\n    return this\n  }\n\n  lte<ColumnName extends string & keyof Row>(column: ColumnName, value: Row[ColumnName]): this\n  lte(column: string, value: unknown): this\n  /**\n   * Match only rows where `column` is less than or equal to `value`.\n   *\n   * @param column - The column to filter on\n   * @param value - The value to filter with\n   */\n  lte(column: string, value: unknown): this {\n    this.url.searchParams.append(column, `lte.${value}`)\n    return this\n  }\n\n  like<ColumnName extends string & keyof Row>(column: ColumnName, pattern: string): this\n  like(column: string, pattern: string): this\n  /**\n   * Match only rows where `column` matches `pattern` case-sensitively.\n   *\n   * @param column - The column to filter on\n   * @param pattern - The pattern to match with\n   */\n  like(column: string, pattern: string): this {\n    this.url.searchParams.append(column, `like.${pattern}`)\n    return this\n  }\n\n  likeAllOf<ColumnName extends string & keyof Row>(\n    column: ColumnName,\n    patterns: readonly string[]\n  ): this\n  likeAllOf(column: string, patterns: readonly string[]): this\n  /**\n   * Match only rows where `column` matches all of `patterns` case-sensitively.\n   *\n   * @param column - The column to filter on\n   * @param patterns - The patterns to match with\n   */\n  likeAllOf(column: string, patterns: readonly string[]): this {\n    this.url.searchParams.append(column, `like(all).{${patterns.join(',')}}`)\n    return this\n  }\n\n  likeAnyOf<ColumnName extends string & keyof Row>(\n    column: ColumnName,\n    patterns: readonly string[]\n  ): this\n  likeAnyOf(column: string, patterns: readonly string[]): this\n  /**\n   * Match only rows where `column` matches any of `patterns` case-sensitively.\n   *\n   * @param column - The column to filter on\n   * @param patterns - The patterns to match with\n   */\n  likeAnyOf(column: string, patterns: readonly string[]): this {\n    this.url.searchParams.append(column, `like(any).{${patterns.join(',')}}`)\n    return this\n  }\n\n  ilike<ColumnName extends string & keyof Row>(column: ColumnName, pattern: string): this\n  ilike(column: string, pattern: string): this\n  /**\n   * Match only rows where `column` matches `pattern` case-insensitively.\n   *\n   * @param column - The column to filter on\n   * @param pattern - The pattern to match with\n   */\n  ilike(column: string, pattern: string): this {\n    this.url.searchParams.append(column, `ilike.${pattern}`)\n    return this\n  }\n\n  ilikeAllOf<ColumnName extends string & keyof Row>(\n    column: ColumnName,\n    patterns: readonly string[]\n  ): this\n  ilikeAllOf(column: string, patterns: readonly string[]): this\n  /**\n   * Match only rows where `column` matches all of `patterns` case-insensitively.\n   *\n   * @param column - The column to filter on\n   * @param patterns - The patterns to match with\n   */\n  ilikeAllOf(column: string, patterns: readonly string[]): this {\n    this.url.searchParams.append(column, `ilike(all).{${patterns.join(',')}}`)\n    return this\n  }\n\n  ilikeAnyOf<ColumnName extends string & keyof Row>(\n    column: ColumnName,\n    patterns: readonly string[]\n  ): this\n  ilikeAnyOf(column: string, patterns: readonly string[]): this\n  /**\n   * Match only rows where `column` matches any of `patterns` case-insensitively.\n   *\n   * @param column - The column to filter on\n   * @param patterns - The patterns to match with\n   */\n  ilikeAnyOf(column: string, patterns: readonly string[]): this {\n    this.url.searchParams.append(column, `ilike(any).{${patterns.join(',')}}`)\n    return this\n  }\n\n  is<ColumnName extends string & keyof Row>(\n    column: ColumnName,\n    value: Row[ColumnName] & (boolean | null)\n  ): this\n  is(column: string, value: boolean | null): this\n  /**\n   * Match only rows where `column` IS `value`.\n   *\n   * For non-boolean columns, this is only relevant for checking if the value of\n   * `column` is NULL by setting `value` to `null`.\n   *\n   * For boolean columns, you can also set `value` to `true` or `false` and it\n   * will behave the same way as `.eq()`.\n   *\n   * @param column - The column to filter on\n   * @param value - The value to filter with\n   */\n  is(column: string, value: boolean | null): this {\n    this.url.searchParams.append(column, `is.${value}`)\n    return this\n  }\n\n  /**\n   * Match only rows where `column` is included in the `values` array.\n   *\n   * @param column - The column to filter on\n   * @param values - The values array to filter with\n   */\n  in<ColumnName extends string>(\n    column: ColumnName,\n    values: ReadonlyArray<\n      ResolveFilterValue<Schema, Row, ColumnName> extends never\n        ? unknown\n        : // We want to infer the type before wrapping it into a `NonNullable` to avoid too deep\n        // type resolution error\n        ResolveFilterValue<Schema, Row, ColumnName> extends infer ResolvedFilterValue\n        ? ResolvedFilterValue\n        : // We should never enter this case as all the branches are covered above\n          never\n    >\n  ): this {\n    const cleanedValues = Array.from(new Set(values))\n      .map((s) => {\n        // handle postgrest reserved characters\n        // https://postgrest.org/en/v7.0.0/api.html#reserved-characters\n        if (typeof s === 'string' && new RegExp('[,()]').test(s)) return `\"${s}\"`\n        else return `${s}`\n      })\n      .join(',')\n    this.url.searchParams.append(column, `in.(${cleanedValues})`)\n    return this\n  }\n\n  contains<ColumnName extends string & keyof Row>(\n    column: ColumnName,\n    value: string | ReadonlyArray<Row[ColumnName]> | Record<string, unknown>\n  ): this\n  contains(column: string, value: string | readonly unknown[] | Record<string, unknown>): this\n  /**\n   * Only relevant for jsonb, array, and range columns. Match only rows where\n   * `column` contains every element appearing in `value`.\n   *\n   * @param column - The jsonb, array, or range column to filter on\n   * @param value - The jsonb, array, or range value to filter with\n   */\n  contains(column: string, value: string | readonly unknown[] | Record<string, unknown>): this {\n    if (typeof value === 'string') {\n      // range types can be inclusive '[', ']' or exclusive '(', ')' so just\n      // keep it simple and accept a string\n      this.url.searchParams.append(column, `cs.${value}`)\n    } else if (Array.isArray(value)) {\n      // array\n      this.url.searchParams.append(column, `cs.{${value.join(',')}}`)\n    } else {\n      // json\n      this.url.searchParams.append(column, `cs.${JSON.stringify(value)}`)\n    }\n    return this\n  }\n\n  containedBy<ColumnName extends string & keyof Row>(\n    column: ColumnName,\n    value: string | ReadonlyArray<Row[ColumnName]> | Record<string, unknown>\n  ): this\n  containedBy(column: string, value: string | readonly unknown[] | Record<string, unknown>): this\n  /**\n   * Only relevant for jsonb, array, and range columns. Match only rows where\n   * every element appearing in `column` is contained by `value`.\n   *\n   * @param column - The jsonb, array, or range column to filter on\n   * @param value - The jsonb, array, or range value to filter with\n   */\n  containedBy(column: string, value: string | readonly unknown[] | Record<string, unknown>): this {\n    if (typeof value === 'string') {\n      // range\n      this.url.searchParams.append(column, `cd.${value}`)\n    } else if (Array.isArray(value)) {\n      // array\n      this.url.searchParams.append(column, `cd.{${value.join(',')}}`)\n    } else {\n      // json\n      this.url.searchParams.append(column, `cd.${JSON.stringify(value)}`)\n    }\n    return this\n  }\n\n  rangeGt<ColumnName extends string & keyof Row>(column: ColumnName, range: string): this\n  rangeGt(column: string, range: string): this\n  /**\n   * Only relevant for range columns. Match only rows where every element in\n   * `column` is greater than any element in `range`.\n   *\n   * @param column - The range column to filter on\n   * @param range - The range to filter with\n   */\n  rangeGt(column: string, range: string): this {\n    this.url.searchParams.append(column, `sr.${range}`)\n    return this\n  }\n\n  rangeGte<ColumnName extends string & keyof Row>(column: ColumnName, range: string): this\n  rangeGte(column: string, range: string): this\n  /**\n   * Only relevant for range columns. Match only rows where every element in\n   * `column` is either contained in `range` or greater than any element in\n   * `range`.\n   *\n   * @param column - The range column to filter on\n   * @param range - The range to filter with\n   */\n  rangeGte(column: string, range: string): this {\n    this.url.searchParams.append(column, `nxl.${range}`)\n    return this\n  }\n\n  rangeLt<ColumnName extends string & keyof Row>(column: ColumnName, range: string): this\n  rangeLt(column: string, range: string): this\n  /**\n   * Only relevant for range columns. Match only rows where every element in\n   * `column` is less than any element in `range`.\n   *\n   * @param column - The range column to filter on\n   * @param range - The range to filter with\n   */\n  rangeLt(column: string, range: string): this {\n    this.url.searchParams.append(column, `sl.${range}`)\n    return this\n  }\n\n  rangeLte<ColumnName extends string & keyof Row>(column: ColumnName, range: string): this\n  rangeLte(column: string, range: string): this\n  /**\n   * Only relevant for range columns. Match only rows where every element in\n   * `column` is either contained in `range` or less than any element in\n   * `range`.\n   *\n   * @param column - The range column to filter on\n   * @param range - The range to filter with\n   */\n  rangeLte(column: string, range: string): this {\n    this.url.searchParams.append(column, `nxr.${range}`)\n    return this\n  }\n\n  rangeAdjacent<ColumnName extends string & keyof Row>(column: ColumnName, range: string): this\n  rangeAdjacent(column: string, range: string): this\n  /**\n   * Only relevant for range columns. Match only rows where `column` is\n   * mutually exclusive to `range` and there can be no element between the two\n   * ranges.\n   *\n   * @param column - The range column to filter on\n   * @param range - The range to filter with\n   */\n  rangeAdjacent(column: string, range: string): this {\n    this.url.searchParams.append(column, `adj.${range}`)\n    return this\n  }\n\n  overlaps<ColumnName extends string & keyof Row>(\n    column: ColumnName,\n    value: string | ReadonlyArray<Row[ColumnName]>\n  ): this\n  overlaps(column: string, value: string | readonly unknown[]): this\n  /**\n   * Only relevant for array and range columns. Match only rows where\n   * `column` and `value` have an element in common.\n   *\n   * @param column - The array or range column to filter on\n   * @param value - The array or range value to filter with\n   */\n  overlaps(column: string, value: string | readonly unknown[]): this {\n    if (typeof value === 'string') {\n      // range\n      this.url.searchParams.append(column, `ov.${value}`)\n    } else {\n      // array\n      this.url.searchParams.append(column, `ov.{${value.join(',')}}`)\n    }\n    return this\n  }\n\n  textSearch<ColumnName extends string & keyof Row>(\n    column: ColumnName,\n    query: string,\n    options?: { config?: string; type?: 'plain' | 'phrase' | 'websearch' }\n  ): this\n  textSearch(\n    column: string,\n    query: string,\n    options?: { config?: string; type?: 'plain' | 'phrase' | 'websearch' }\n  ): this\n  /**\n   * Only relevant for text and tsvector columns. Match only rows where\n   * `column` matches the query string in `query`.\n   *\n   * @param column - The text or tsvector column to filter on\n   * @param query - The query text to match with\n   * @param options - Named parameters\n   * @param options.config - The text search configuration to use\n   * @param options.type - Change how the `query` text is interpreted\n   */\n  textSearch(\n    column: string,\n    query: string,\n    { config, type }: { config?: string; type?: 'plain' | 'phrase' | 'websearch' } = {}\n  ): this {\n    let typePart = ''\n    if (type === 'plain') {\n      typePart = 'pl'\n    } else if (type === 'phrase') {\n      typePart = 'ph'\n    } else if (type === 'websearch') {\n      typePart = 'w'\n    }\n    const configPart = config === undefined ? '' : `(${config})`\n    this.url.searchParams.append(column, `${typePart}fts${configPart}.${query}`)\n    return this\n  }\n\n  match<ColumnName extends string & keyof Row>(query: Record<ColumnName, Row[ColumnName]>): this\n  match(query: Record<string, unknown>): this\n  /**\n   * Match only rows where each column in `query` keys is equal to its\n   * associated value. Shorthand for multiple `.eq()`s.\n   *\n   * @param query - The object to filter with, with column names as keys mapped\n   * to their filter values\n   */\n  match(query: Record<string, unknown>): this {\n    Object.entries(query).forEach(([column, value]) => {\n      this.url.searchParams.append(column, `eq.${value}`)\n    })\n    return this\n  }\n\n  not<ColumnName extends string & keyof Row>(\n    column: ColumnName,\n    operator: FilterOperator,\n    value: Row[ColumnName]\n  ): this\n  not(column: string, operator: string, value: unknown): this\n  /**\n   * Match only rows which doesn't satisfy the filter.\n   *\n   * Unlike most filters, `opearator` and `value` are used as-is and need to\n   * follow [PostgREST\n   * syntax](https://postgrest.org/en/stable/api.html#operators). You also need\n   * to make sure they are properly sanitized.\n   *\n   * @param column - The column to filter on\n   * @param operator - The operator to be negated to filter with, following\n   * PostgREST syntax\n   * @param value - The value to filter with, following PostgREST syntax\n   */\n  not(column: string, operator: string, value: unknown): this {\n    this.url.searchParams.append(column, `not.${operator}.${value}`)\n    return this\n  }\n\n  /**\n   * Match only rows which satisfy at least one of the filters.\n   *\n   * Unlike most filters, `filters` is used as-is and needs to follow [PostgREST\n   * syntax](https://postgrest.org/en/stable/api.html#operators). You also need\n   * to make sure it's properly sanitized.\n   *\n   * It's currently not possible to do an `.or()` filter across multiple tables.\n   *\n   * @param filters - The filters to use, following PostgREST syntax\n   * @param options - Named parameters\n   * @param options.referencedTable - Set this to filter on referenced tables\n   * instead of the parent table\n   * @param options.foreignTable - Deprecated, use `referencedTable` instead\n   */\n  or(\n    filters: string,\n    {\n      foreignTable,\n      referencedTable = foreignTable,\n    }: { foreignTable?: string; referencedTable?: string } = {}\n  ): this {\n    const key = referencedTable ? `${referencedTable}.or` : 'or'\n    this.url.searchParams.append(key, `(${filters})`)\n    return this\n  }\n\n  filter<ColumnName extends string & keyof Row>(\n    column: ColumnName,\n    operator: `${'' | 'not.'}${FilterOperator}`,\n    value: unknown\n  ): this\n  filter(column: string, operator: string, value: unknown): this\n  /**\n   * Match only rows which satisfy the filter. This is an escape hatch - you\n   * should use the specific filter methods wherever possible.\n   *\n   * Unlike most filters, `opearator` and `value` are used as-is and need to\n   * follow [PostgREST\n   * syntax](https://postgrest.org/en/stable/api.html#operators). You also need\n   * to make sure they are properly sanitized.\n   *\n   * @param column - The column to filter on\n   * @param operator - The operator to filter with, following PostgREST syntax\n   * @param value - The value to filter with, following PostgREST syntax\n   */\n  filter(column: string, operator: string, value: unknown): this {\n    this.url.searchParams.append(column, `${operator}.${value}`)\n    return this\n  }\n}\n", "import PostgrestFilterBuilder from './PostgrestFilterBuilder'\nimport { GetResult } from './select-query-parser/result'\nimport { ClientServerOptions, Fetch, GenericSchema, GenericTable, GenericView } from './types'\n\nexport default class PostgrestQueryBuilder<\n  ClientOptions extends ClientServerOptions,\n  Schema extends GenericSchema,\n  Relation extends GenericTable | GenericView,\n  RelationName = unknown,\n  Relationships = Relation extends { Relationships: infer R } ? R : unknown\n> {\n  url: URL\n  headers: Headers\n  schema?: string\n  signal?: AbortSignal\n  fetch?: Fetch\n\n  constructor(\n    url: URL,\n    {\n      headers = {},\n      schema,\n      fetch,\n    }: {\n      headers?: HeadersInit\n      schema?: string\n      fetch?: Fetch\n    }\n  ) {\n    this.url = url\n    this.headers = new Headers(headers)\n    this.schema = schema\n    this.fetch = fetch\n  }\n\n  /**\n   * Perform a SELECT query on the table or view.\n   *\n   * @param columns - The columns to retrieve, separated by commas. Columns can be renamed when returned with `customName:columnName`\n   *\n   * @param options - Named parameters\n   *\n   * @param options.head - When set to `true`, `data` will not be returned.\n   * Useful if you only need the count.\n   *\n   * @param options.count - Count algorithm to use to count rows in the table or view.\n   *\n   * `\"exact\"`: Exact but slow count algorithm. Performs a `COUNT(*)` under the\n   * hood.\n   *\n   * `\"planned\"`: Approximated but fast count algorithm. Uses the Postgres\n   * statistics under the hood.\n   *\n   * `\"estimated\"`: Uses exact count for low numbers and planned count for high\n   * numbers.\n   */\n  select<\n    Query extends string = '*',\n    ResultOne = GetResult<\n      Schema,\n      Relation['Row'],\n      RelationName,\n      Relationships,\n      Query,\n      ClientOptions\n    >\n  >(\n    columns?: Query,\n    {\n      head = false,\n      count,\n    }: {\n      head?: boolean\n      count?: 'exact' | 'planned' | 'estimated'\n    } = {}\n  ): PostgrestFilterBuilder<\n    ClientOptions,\n    Schema,\n    Relation['Row'],\n    ResultOne[],\n    RelationName,\n    Relationships,\n    'GET'\n  > {\n    const method = head ? 'HEAD' : 'GET'\n    // Remove whitespaces except when quoted\n    let quoted = false\n    const cleanedColumns = (columns ?? '*')\n      .split('')\n      .map((c) => {\n        if (/\\s/.test(c) && !quoted) {\n          return ''\n        }\n        if (c === '\"') {\n          quoted = !quoted\n        }\n        return c\n      })\n      .join('')\n    this.url.searchParams.set('select', cleanedColumns)\n\n    if (count) {\n      this.headers.append('Prefer', `count=${count}`)\n    }\n\n    return new PostgrestFilterBuilder({\n      method,\n      url: this.url,\n      headers: this.headers,\n      schema: this.schema,\n      fetch: this.fetch,\n    })\n  }\n\n  // TODO(v3): Make `defaultToNull` consistent for both single & bulk inserts.\n  insert<Row extends Relation extends { Insert: unknown } ? Relation['Insert'] : never>(\n    values: Row,\n    options?: {\n      count?: 'exact' | 'planned' | 'estimated'\n    }\n  ): PostgrestFilterBuilder<\n    ClientOptions,\n    Schema,\n    Relation['Row'],\n    null,\n    RelationName,\n    Relationships,\n    'POST'\n  >\n  insert<Row extends Relation extends { Insert: unknown } ? Relation['Insert'] : never>(\n    values: Row[],\n    options?: {\n      count?: 'exact' | 'planned' | 'estimated'\n      defaultToNull?: boolean\n    }\n  ): PostgrestFilterBuilder<\n    ClientOptions,\n    Schema,\n    Relation['Row'],\n    null,\n    RelationName,\n    Relationships,\n    'POST'\n  >\n  /**\n   * Perform an INSERT into the table or view.\n   *\n   * By default, inserted rows are not returned. To return it, chain the call\n   * with `.select()`.\n   *\n   * @param values - The values to insert. Pass an object to insert a single row\n   * or an array to insert multiple rows.\n   *\n   * @param options - Named parameters\n   *\n   * @param options.count - Count algorithm to use to count inserted rows.\n   *\n   * `\"exact\"`: Exact but slow count algorithm. Performs a `COUNT(*)` under the\n   * hood.\n   *\n   * `\"planned\"`: Approximated but fast count algorithm. Uses the Postgres\n   * statistics under the hood.\n   *\n   * `\"estimated\"`: Uses exact count for low numbers and planned count for high\n   * numbers.\n   *\n   * @param options.defaultToNull - Make missing fields default to `null`.\n   * Otherwise, use the default value for the column. Only applies for bulk\n   * inserts.\n   */\n  insert<Row extends Relation extends { Insert: unknown } ? Relation['Insert'] : never>(\n    values: Row | Row[],\n    {\n      count,\n      defaultToNull = true,\n    }: {\n      count?: 'exact' | 'planned' | 'estimated'\n      defaultToNull?: boolean\n    } = {}\n  ): PostgrestFilterBuilder<\n    ClientOptions,\n    Schema,\n    Relation['Row'],\n    null,\n    RelationName,\n    Relationships,\n    'POST'\n  > {\n    const method = 'POST'\n\n    if (count) {\n      this.headers.append('Prefer', `count=${count}`)\n    }\n    if (!defaultToNull) {\n      this.headers.append('Prefer', `missing=default`)\n    }\n\n    if (Array.isArray(values)) {\n      const columns = values.reduce((acc, x) => acc.concat(Object.keys(x)), [] as string[])\n      if (columns.length > 0) {\n        const uniqueColumns = [...new Set(columns)].map((column) => `\"${column}\"`)\n        this.url.searchParams.set('columns', uniqueColumns.join(','))\n      }\n    }\n\n    return new PostgrestFilterBuilder({\n      method,\n      url: this.url,\n      headers: this.headers,\n      schema: this.schema,\n      body: values,\n      fetch: this.fetch ?? fetch,\n    })\n  }\n\n  // TODO(v3): Make `defaultToNull` consistent for both single & bulk upserts.\n  upsert<Row extends Relation extends { Insert: unknown } ? Relation['Insert'] : never>(\n    values: Row,\n    options?: {\n      onConflict?: string\n      ignoreDuplicates?: boolean\n      count?: 'exact' | 'planned' | 'estimated'\n    }\n  ): PostgrestFilterBuilder<\n    ClientOptions,\n    Schema,\n    Relation['Row'],\n    null,\n    RelationName,\n    Relationships,\n    'POST'\n  >\n  upsert<Row extends Relation extends { Insert: unknown } ? Relation['Insert'] : never>(\n    values: Row[],\n    options?: {\n      onConflict?: string\n      ignoreDuplicates?: boolean\n      count?: 'exact' | 'planned' | 'estimated'\n      defaultToNull?: boolean\n    }\n  ): PostgrestFilterBuilder<\n    ClientOptions,\n    Schema,\n    Relation['Row'],\n    null,\n    RelationName,\n    Relationships,\n    'POST'\n  >\n  /**\n   * Perform an UPSERT on the table or view. Depending on the column(s) passed\n   * to `onConflict`, `.upsert()` allows you to perform the equivalent of\n   * `.insert()` if a row with the corresponding `onConflict` columns doesn't\n   * exist, or if it does exist, perform an alternative action depending on\n   * `ignoreDuplicates`.\n   *\n   * By default, upserted rows are not returned. To return it, chain the call\n   * with `.select()`.\n   *\n   * @param values - The values to upsert with. Pass an object to upsert a\n   * single row or an array to upsert multiple rows.\n   *\n   * @param options - Named parameters\n   *\n   * @param options.onConflict - Comma-separated UNIQUE column(s) to specify how\n   * duplicate rows are determined. Two rows are duplicates if all the\n   * `onConflict` columns are equal.\n   *\n   * @param options.ignoreDuplicates - If `true`, duplicate rows are ignored. If\n   * `false`, duplicate rows are merged with existing rows.\n   *\n   * @param options.count - Count algorithm to use to count upserted rows.\n   *\n   * `\"exact\"`: Exact but slow count algorithm. Performs a `COUNT(*)` under the\n   * hood.\n   *\n   * `\"planned\"`: Approximated but fast count algorithm. Uses the Postgres\n   * statistics under the hood.\n   *\n   * `\"estimated\"`: Uses exact count for low numbers and planned count for high\n   * numbers.\n   *\n   * @param options.defaultToNull - Make missing fields default to `null`.\n   * Otherwise, use the default value for the column. This only applies when\n   * inserting new rows, not when merging with existing rows under\n   * `ignoreDuplicates: false`. This also only applies when doing bulk upserts.\n   */\n  upsert<Row extends Relation extends { Insert: unknown } ? Relation['Insert'] : never>(\n    values: Row | Row[],\n    {\n      onConflict,\n      ignoreDuplicates = false,\n      count,\n      defaultToNull = true,\n    }: {\n      onConflict?: string\n      ignoreDuplicates?: boolean\n      count?: 'exact' | 'planned' | 'estimated'\n      defaultToNull?: boolean\n    } = {}\n  ): PostgrestFilterBuilder<\n    ClientOptions,\n    Schema,\n    Relation['Row'],\n    null,\n    RelationName,\n    Relationships,\n    'POST'\n  > {\n    const method = 'POST'\n\n    this.headers.append('Prefer', `resolution=${ignoreDuplicates ? 'ignore' : 'merge'}-duplicates`)\n\n    if (onConflict !== undefined) this.url.searchParams.set('on_conflict', onConflict)\n    if (count) {\n      this.headers.append('Prefer', `count=${count}`)\n    }\n    if (!defaultToNull) {\n      this.headers.append('Prefer', 'missing=default')\n    }\n\n    if (Array.isArray(values)) {\n      const columns = values.reduce((acc, x) => acc.concat(Object.keys(x)), [] as string[])\n      if (columns.length > 0) {\n        const uniqueColumns = [...new Set(columns)].map((column) => `\"${column}\"`)\n        this.url.searchParams.set('columns', uniqueColumns.join(','))\n      }\n    }\n\n    return new PostgrestFilterBuilder({\n      method,\n      url: this.url,\n      headers: this.headers,\n      schema: this.schema,\n      body: values,\n      fetch: this.fetch ?? fetch,\n    })\n  }\n\n  /**\n   * Perform an UPDATE on the table or view.\n   *\n   * By default, updated rows are not returned. To return it, chain the call\n   * with `.select()` after filters.\n   *\n   * @param values - The values to update with\n   *\n   * @param options - Named parameters\n   *\n   * @param options.count - Count algorithm to use to count updated rows.\n   *\n   * `\"exact\"`: Exact but slow count algorithm. Performs a `COUNT(*)` under the\n   * hood.\n   *\n   * `\"planned\"`: Approximated but fast count algorithm. Uses the Postgres\n   * statistics under the hood.\n   *\n   * `\"estimated\"`: Uses exact count for low numbers and planned count for high\n   * numbers.\n   */\n  update<Row extends Relation extends { Update: unknown } ? Relation['Update'] : never>(\n    values: Row,\n    {\n      count,\n    }: {\n      count?: 'exact' | 'planned' | 'estimated'\n    } = {}\n  ): PostgrestFilterBuilder<\n    ClientOptions,\n    Schema,\n    Relation['Row'],\n    null,\n    RelationName,\n    Relationships,\n    'PATCH'\n  > {\n    const method = 'PATCH'\n    if (count) {\n      this.headers.append('Prefer', `count=${count}`)\n    }\n\n    return new PostgrestFilterBuilder({\n      method,\n      url: this.url,\n      headers: this.headers,\n      schema: this.schema,\n      body: values,\n      fetch: this.fetch ?? fetch,\n    })\n  }\n\n  /**\n   * Perform a DELETE on the table or view.\n   *\n   * By default, deleted rows are not returned. To return it, chain the call\n   * with `.select()` after filters.\n   *\n   * @param options - Named parameters\n   *\n   * @param options.count - Count algorithm to use to count deleted rows.\n   *\n   * `\"exact\"`: Exact but slow count algorithm. Performs a `COUNT(*)` under the\n   * hood.\n   *\n   * `\"planned\"`: Approximated but fast count algorithm. Uses the Postgres\n   * statistics under the hood.\n   *\n   * `\"estimated\"`: Uses exact count for low numbers and planned count for high\n   * numbers.\n   */\n  delete({\n    count,\n  }: {\n    count?: 'exact' | 'planned' | 'estimated'\n  } = {}): PostgrestFilterBuilder<\n    ClientOptions,\n    Schema,\n    Relation['Row'],\n    null,\n    RelationName,\n    Relationships,\n    'DELETE'\n  > {\n    const method = 'DELETE'\n    if (count) {\n      this.headers.append('Prefer', `count=${count}`)\n    }\n\n    return new PostgrestFilterBuilder({\n      method,\n      url: this.url,\n      headers: this.headers,\n      schema: this.schema,\n      fetch: this.fetch ?? fetch,\n    })\n  }\n}\n", "import PostgrestQueryBuilder from './PostgrestQueryBuilder'\nimport PostgrestFilterBuilder from './PostgrestFilterBuilder'\nimport { Fetch, GenericSchema, ClientServerOptions, GetGenericDatabaseWithOptions } from './types'\n\n/**\n * PostgREST client.\n *\n * @typeParam Database - Types for the schema from the [type\n * generator](https://supabase.com/docs/reference/javascript/next/typescript-support)\n *\n * @typeParam SchemaName - Postgres schema to switch to. Must be a string\n * literal, the same one passed to the constructor. If the schema is not\n * `\"public\"`, this must be supplied manually.\n */\nexport default class PostgrestClient<\n  Database = any,\n  ClientOptions extends ClientServerOptions = GetGenericDatabaseWithOptions<\n    Database,\n    { PostgrestVersion: '12' }\n  >['options'],\n  SchemaName extends string &\n    keyof GetGenericDatabaseWithOptions<Database>['db'] = 'public' extends keyof GetGenericDatabaseWithOptions<Database>['db']\n    ? 'public'\n    : string & keyof GetGenericDatabaseWithOptions<Database>['db'],\n  Schema extends GenericSchema = GetGenericDatabaseWithOptions<Database>['db'][SchemaName] extends GenericSchema\n    ? GetGenericDatabaseWithOptions<Database>['db'][SchemaName]\n    : any\n> {\n  url: string\n  headers: Headers\n  schemaName?: SchemaName\n  fetch?: Fetch\n\n  // TODO: Add back shouldThrowOnError once we figure out the typings\n  /**\n   * Creates a PostgREST client.\n   *\n   * @param url - URL of the PostgREST endpoint\n   * @param options - Named parameters\n   * @param options.headers - Custom headers\n   * @param options.schema - Postgres schema to switch to\n   * @param options.fetch - Custom fetch\n   */\n  constructor(\n    url: string,\n    {\n      headers = {},\n      schema,\n      fetch,\n    }: {\n      headers?: HeadersInit\n      schema?: SchemaName\n      fetch?: Fetch\n    } = {}\n  ) {\n    this.url = url\n    this.headers = new Headers(headers)\n    this.schemaName = schema\n    this.fetch = fetch\n  }\n  from<\n    TableName extends string & keyof Schema['Tables'],\n    Table extends Schema['Tables'][TableName]\n  >(relation: TableName): PostgrestQueryBuilder<ClientOptions, Schema, Table, TableName>\n  from<ViewName extends string & keyof Schema['Views'], View extends Schema['Views'][ViewName]>(\n    relation: ViewName\n  ): PostgrestQueryBuilder<ClientOptions, Schema, View, ViewName>\n  /**\n   * Perform a query on a table or a view.\n   *\n   * @param relation - The table or view name to query\n   */\n  from(relation: string): PostgrestQueryBuilder<ClientOptions, Schema, any, any> {\n    const url = new URL(`${this.url}/${relation}`)\n    return new PostgrestQueryBuilder(url, {\n      headers: new Headers(this.headers),\n      schema: this.schemaName,\n      fetch: this.fetch,\n    })\n  }\n\n  /**\n   * Select a schema to query or perform an function (rpc) call.\n   *\n   * The schema needs to be on the list of exposed schemas inside Supabase.\n   *\n   * @param schema - The schema to query\n   */\n  schema<DynamicSchema extends string & keyof GetGenericDatabaseWithOptions<Database>['db']>(\n    schema: DynamicSchema\n  ): PostgrestClient<\n    Database,\n    ClientOptions,\n    DynamicSchema,\n    Database[DynamicSchema] extends GenericSchema ? Database[DynamicSchema] : any\n  > {\n    return new PostgrestClient(this.url, {\n      headers: this.headers,\n      schema,\n      fetch: this.fetch,\n    })\n  }\n\n  /**\n   * Perform a function call.\n   *\n   * @param fn - The function name to call\n   * @param args - The arguments to pass to the function call\n   * @param options - Named parameters\n   * @param options.head - When set to `true`, `data` will not be returned.\n   * Useful if you only need the count.\n   * @param options.get - When set to `true`, the function will be called with\n   * read-only access mode.\n   * @param options.count - Count algorithm to use to count rows returned by the\n   * function. Only applicable for [set-returning\n   * functions](https://www.postgresql.org/docs/current/functions-srf.html).\n   *\n   * `\"exact\"`: Exact but slow count algorithm. Performs a `COUNT(*)` under the\n   * hood.\n   *\n   * `\"planned\"`: Approximated but fast count algorithm. Uses the Postgres\n   * statistics under the hood.\n   *\n   * `\"estimated\"`: Uses exact count for low numbers and planned count for high\n   * numbers.\n   */\n  rpc<FnName extends string & keyof Schema['Functions'], Fn extends Schema['Functions'][FnName]>(\n    fn: FnName,\n    args: Fn['Args'] = {},\n    {\n      head = false,\n      get = false,\n      count,\n    }: {\n      head?: boolean\n      get?: boolean\n      count?: 'exact' | 'planned' | 'estimated'\n    } = {}\n  ): PostgrestFilterBuilder<\n    ClientOptions,\n    Schema,\n    Fn['Returns'] extends any[]\n      ? Fn['Returns'][number] extends Record<string, unknown>\n        ? Fn['Returns'][number]\n        : never\n      : never,\n    Fn['Returns'],\n    FnName,\n    null,\n    'RPC'\n  > {\n    let method: 'HEAD' | 'GET' | 'POST'\n    const url = new URL(`${this.url}/rpc/${fn}`)\n    let body: unknown | undefined\n    if (head || get) {\n      method = head ? 'HEAD' : 'GET'\n      Object.entries(args)\n        // params with undefined value needs to be filtered out, otherwise it'll\n        // show up as `?param=undefined`\n        .filter(([_, value]) => value !== undefined)\n        // array values need special syntax\n        .map(([name, value]) => [name, Array.isArray(value) ? `{${value.join(',')}}` : `${value}`])\n        .forEach(([name, value]) => {\n          url.searchParams.append(name, value)\n        })\n    } else {\n      method = 'POST'\n      body = args\n    }\n\n    const headers = new Headers(this.headers)\n    if (count) {\n      headers.set('Prefer', `count=${count}`)\n    }\n\n    return new PostgrestFilterBuilder({\n      method,\n      url,\n      headers,\n      schema: this.schemaName,\n      body,\n      fetch: this.fetch ?? fetch,\n    })\n  }\n}\n", "// Always update wrapper.mjs when updating this file.\nimport PostgrestClient from './PostgrestClient'\nimport PostgrestQueryBuilder from './PostgrestQueryBuilder'\nimport PostgrestFilterBuilder from './PostgrestFilterBuilder'\nimport PostgrestTransformBuilder from './PostgrestTransformBuilder'\nimport PostgrestBuilder from './PostgrestBuilder'\nimport PostgrestError from './PostgrestError'\n\nexport {\n  PostgrestClient,\n  PostgrestQueryBuilder,\n  PostgrestFilterBuilder,\n  PostgrestTransformBuilder,\n  PostgrestBuilder,\n  PostgrestError,\n}\nexport default {\n  PostgrestClient,\n  PostgrestQueryBuilder,\n  PostgrestFilterBuilder,\n  PostgrestTransformBuilder,\n  PostgrestBuilder,\n  PostgrestError,\n}\nexport type {\n  PostgrestResponse,\n  PostgrestResponseFailure,\n  PostgrestResponseSuccess,\n  PostgrestSingleResponse,\n  PostgrestMaybeSingleResponse,\n  ClientServerOptions,\n  GetGenericDatabaseWithOptions,\n} from './types'\n// https://github.com/supabase/postgrest-js/issues/551\n// To be replaced with a helper type that only uses public types\nexport type { GetResult as UnstableGetResult } from './select-query-parser/result'\n", "import { Fetch } from './types'\n\nexport const resolveFetch = (customFetch?: Fetch): Fetch => {\n  let _fetch: Fetch\n  if (customFetch) {\n    _fetch = customFetch\n  } else if (typeof fetch === 'undefined') {\n    _fetch = (...args) =>\n      import('@supabase/node-fetch' as any).then(({ default: fetch }) => fetch(...args))\n  } else {\n    _fetch = fetch\n  }\n  return (...args) => _fetch(...args)\n}\n", "export type Fetch = typeof fetch\n\n/**\n * Response format\n */\nexport interface FunctionsResponseSuccess<T> {\n  data: T\n  error: null\n  response?: Response\n}\nexport interface FunctionsResponseFailure {\n  data: null\n  error: any\n  response?: Response\n}\nexport type FunctionsResponse<T> = FunctionsResponseSuccess<T> | FunctionsResponseFailure\n\nexport class FunctionsError extends Error {\n  context: any\n  constructor(message: string, name = 'FunctionsError', context?: any) {\n    super(message)\n    this.name = name\n    this.context = context\n  }\n}\n\nexport class FunctionsFetchError extends FunctionsError {\n  constructor(context: any) {\n    super('Failed to send a request to the Edge Function', 'FunctionsFetchError', context)\n  }\n}\n\nexport class FunctionsRelayError extends FunctionsError {\n  constructor(context: any) {\n    super('Relay Error invoking the Edge Function', 'FunctionsRelayError', context)\n  }\n}\n\nexport class FunctionsHttpError extends FunctionsError {\n  constructor(context: any) {\n    super('Edge Function returned a non-2xx status code', 'FunctionsHttpError', context)\n  }\n}\n// Define the enum for the 'region' property\nexport enum FunctionRegion {\n  Any = 'any',\n  ApNortheast1 = 'ap-northeast-1',\n  ApNortheast2 = 'ap-northeast-2',\n  ApSouth1 = 'ap-south-1',\n  ApSoutheast1 = 'ap-southeast-1',\n  ApSoutheast2 = 'ap-southeast-2',\n  CaCentral1 = 'ca-central-1',\n  EuCentral1 = 'eu-central-1',\n  EuWest1 = 'eu-west-1',\n  EuWest2 = 'eu-west-2',\n  EuWest3 = 'eu-west-3',\n  SaEast1 = 'sa-east-1',\n  UsEast1 = 'us-east-1',\n  UsWest1 = 'us-west-1',\n  UsWest2 = 'us-west-2',\n}\n\nexport type FunctionInvokeOptions = {\n  /**\n   * Object representing the headers to send with the request.\n   */\n  headers?: { [key: string]: string }\n  /**\n   * The HTTP verb of the request\n   */\n  method?: 'POST' | 'GET' | 'PUT' | 'PATCH' | 'DELETE'\n  /**\n   * The Region to invoke the function in.\n   */\n  region?: FunctionRegion\n  /**\n   * The body of the request.\n   */\n  body?:\n    | File\n    | Blob\n    | ArrayBuffer\n    | FormData\n    | ReadableStream<Uint8Array>\n    | Record<string, any>\n    | string\n}\n", "import { resolveFetch } from './helper'\nimport {\n  Fetch,\n  FunctionsFetchError,\n  FunctionsHttpError,\n  FunctionsRelayError,\n  FunctionsResponse,\n  FunctionInvokeOptions,\n  FunctionRegion,\n} from './types'\n\nexport class FunctionsClient {\n  protected url: string\n  protected headers: Record<string, string>\n  protected region: FunctionRegion\n  protected fetch: Fetch\n\n  constructor(\n    url: string,\n    {\n      headers = {},\n      customFetch,\n      region = FunctionRegion.Any,\n    }: {\n      headers?: Record<string, string>\n      customFetch?: Fetch\n      region?: FunctionRegion\n    } = {}\n  ) {\n    this.url = url\n    this.headers = headers\n    this.region = region\n    this.fetch = resolveFetch(customFetch)\n  }\n\n  /**\n   * Updates the authorization header\n   * @param token - the new jwt token sent in the authorisation header\n   */\n  setAuth(token: string) {\n    this.headers.Authorization = `Bearer ${token}`\n  }\n\n  /**\n   * Invokes a function\n   * @param functionName - The name of the Function to invoke.\n   * @param options - Options for invoking the Function.\n   */\n  async invoke<T = any>(\n    functionName: string,\n    options: FunctionInvokeOptions = {}\n  ): Promise<FunctionsResponse<T>> {\n    try {\n      const { headers, method, body: functionArgs } = options\n      let _headers: Record<string, string> = {}\n      let { region } = options\n      if (!region) {\n        region = this.region\n      }\n      // Add region as query parameter using URL API\n      const url = new URL(`${this.url}/${functionName}`)\n      if (region && region !== 'any') {\n        _headers['x-region'] = region\n        url.searchParams.set('forceFunctionRegion', region)\n      }\n      let body: any\n      if (\n        functionArgs &&\n        ((headers && !Object.prototype.hasOwnProperty.call(headers, 'Content-Type')) || !headers)\n      ) {\n        if (\n          (typeof Blob !== 'undefined' && functionArgs instanceof Blob) ||\n          functionArgs instanceof ArrayBuffer\n        ) {\n          // will work for File as File inherits Blob\n          // also works for ArrayBuffer as it is the same underlying structure as a Blob\n          _headers['Content-Type'] = 'application/octet-stream'\n          body = functionArgs\n        } else if (typeof functionArgs === 'string') {\n          // plain string\n          _headers['Content-Type'] = 'text/plain'\n          body = functionArgs\n        } else if (typeof FormData !== 'undefined' && functionArgs instanceof FormData) {\n          // don't set content-type headers\n          // Request will automatically add the right boundary value\n          body = functionArgs\n        } else {\n          // default, assume this is JSON\n          _headers['Content-Type'] = 'application/json'\n          body = JSON.stringify(functionArgs)\n        }\n      }\n\n      const response = await this.fetch(url.toString(), {\n        method: method || 'POST',\n        // headers priority is (high to low):\n        // 1. invoke-level headers\n        // 2. client-level headers\n        // 3. default Content-Type header\n        headers: { ..._headers, ...this.headers, ...headers },\n        body,\n      }).catch((fetchError) => {\n        throw new FunctionsFetchError(fetchError)\n      })\n\n      const isRelayError = response.headers.get('x-relay-error')\n      if (isRelayError && isRelayError === 'true') {\n        throw new FunctionsRelayError(response)\n      }\n\n      if (!response.ok) {\n        throw new FunctionsHttpError(response)\n      }\n\n      let responseType = (response.headers.get('Content-Type') ?? 'text/plain').split(';')[0].trim()\n      let data: any\n      if (responseType === 'application/json') {\n        data = await response.json()\n      } else if (responseType === 'application/octet-stream') {\n        data = await response.blob()\n      } else if (responseType === 'text/event-stream') {\n        data = response\n      } else if (responseType === 'multipart/form-data') {\n        data = await response.formData()\n      } else {\n        // default to text\n        data = await response.text()\n      }\n\n      return { data, error: null, response }\n    } catch (error) {\n      return {\n        data: null,\n        error,\n        response:\n          error instanceof FunctionsHttpError || error instanceof FunctionsRelayError\n            ? error.context\n            : undefined,\n      }\n    }\n  }\n}\n", "import index from '../cjs/index.js'\nconst {\n  PostgrestClient,\n  PostgrestQueryBuilder,\n  PostgrestFilterBuilder,\n  PostgrestTransformBuilder,\n  PostgrestBuilder,\n  PostgrestError,\n} = index\n\nexport {\n  PostgrestBuilder,\n  PostgrestClient,\n  PostgrestFilterBuilder,\n  PostgrestQueryBuilder,\n  PostgrestTransformBuilder,\n  PostgrestError,\n}\n\n// compatibility with CJS output\nexport default {\n  PostgrestClient,\n  PostgrestQueryBuilder,\n  PostgrestFilterBuilder,\n  PostgrestTransformBuilder,\n  PostgrestBuilder,\n  PostgrestError,\n}\n", "export function getNativeWebSocket() {\n  if (typeof WebSocket !== \"undefined\") return WebSocket;\n  if (typeof global.WebSocket !== \"undefined\") return global.WebSocket;\n  if (typeof window.WebSocket !== \"undefined\") return window.WebSocket;\n  if (typeof self.WebSocket !== \"undefined\") return self.WebSocket;\n  throw new Error(\"`WebSocket` is not supported in this environment\");\n}\n", "import { getNativeWebSocket } from \"./utils.js\";\n\nexport const WebSocket = getNativeWebSocket();\n\ntype MessageEvent_ = MessageEvent;\nexport type { MessageEvent_ as MessageEvent };\n", "export const version = '2.12.2'\n", "import { version } from './version'\n\nexport const DEFAULT_VERSION = `realtime-js/${version}`\nexport const VSN: string = '1.0.0'\n\nexport const VERSION = version\n\nexport const DEFAULT_TIMEOUT = 10000\n\nexport const WS_CLOSE_NORMAL = 1000\n\nexport enum SOCKET_STATES {\n  connecting = 0,\n  open = 1,\n  closing = 2,\n  closed = 3,\n}\n\nexport enum CHANNEL_STATES {\n  closed = 'closed',\n  errored = 'errored',\n  joined = 'joined',\n  joining = 'joining',\n  leaving = 'leaving',\n}\n\nexport enum CHANNEL_EVENTS {\n  close = 'phx_close',\n  error = 'phx_error',\n  join = 'phx_join',\n  reply = 'phx_reply',\n  leave = 'phx_leave',\n  access_token = 'access_token',\n}\n\nexport enum TRANSPORTS {\n  websocket = 'websocket',\n}\n\nexport enum CONNECTION_STATE {\n  Connecting = 'connecting',\n  Open = 'open',\n  Closing = 'closing',\n  Closed = 'closed',\n}\n", "// This file draws heavily from https://github.com/phoenixframework/phoenix/commit/cf098e9cf7a44ee6479d31d911a97d3c7430c6fe\n// License: https://github.com/phoenixframework/phoenix/blob/master/LICENSE.md\n\nexport default class Serializer {\n  HEADER_LENGTH = 1\n\n  decode(rawPayload: ArrayBuffer | string, callback: Function) {\n    if (rawPayload.constructor === ArrayBuffer) {\n      return callback(this._binaryDecode(rawPayload))\n    }\n\n    if (typeof rawPayload === 'string') {\n      return callback(JSON.parse(rawPayload))\n    }\n\n    return callback({})\n  }\n\n  private _binaryDecode(buffer: ArrayBuffer) {\n    const view = new DataView(buffer)\n    const decoder = new TextDecoder()\n\n    return this._decodeBroadcast(buffer, view, decoder)\n  }\n\n  private _decodeBroadcast(\n    buffer: ArrayBuffer,\n    view: DataView,\n    decoder: TextDecoder\n  ): {\n    ref: null\n    topic: string\n    event: string\n    payload: { [key: string]: any }\n  } {\n    const topicSize = view.getUint8(1)\n    const eventSize = view.getUint8(2)\n    let offset = this.HEADER_LENGTH + 2\n    const topic = decoder.decode(buffer.slice(offset, offset + topicSize))\n    offset = offset + topicSize\n    const event = decoder.decode(buffer.slice(offset, offset + eventSize))\n    offset = offset + eventSize\n    const data = JSON.parse(\n      decoder.decode(buffer.slice(offset, buffer.byteLength))\n    )\n\n    return { ref: null, topic: topic, event: event, payload: data }\n  }\n}\n", "/**\n * Creates a timer that accepts a `timerCalc` function to perform calculated timeout retries, such as exponential backoff.\n *\n * @example\n *    let reconnectTimer = new Timer(() => this.connect(), function(tries){\n *      return [1000, 5000, 10000][tries - 1] || 10000\n *    })\n *    reconnectTimer.scheduleTimeout() // fires after 1000\n *    reconnectTimer.scheduleTimeout() // fires after 5000\n *    reconnectTimer.reset()\n *    reconnectTimer.scheduleTimeout() // fires after 1000\n */\nexport default class Timer {\n  timer: number | undefined = undefined\n  tries: number = 0\n\n  constructor(public callback: Function, public timerCalc: Function) {\n    this.callback = callback\n    this.timerCalc = timerCalc\n  }\n\n  reset() {\n    this.tries = 0\n    clearTimeout(this.timer)\n  }\n\n  // Cancels any previous scheduleTimeout and schedules callback\n  scheduleTimeout() {\n    clearTimeout(this.timer)\n\n    this.timer = <any>setTimeout(() => {\n      this.tries = this.tries + 1\n      this.callback()\n    }, this.timerCalc(this.tries + 1))\n  }\n}\n", "/**\n * Helpers to convert the change Payload into native JS types.\n */\n\n// Adapted from epgsql (src/epgsql_binary.erl), this module licensed under\n// 3-clause BSD found here: https://raw.githubusercontent.com/epgsql/epgsql/devel/LICENSE\n\nexport enum PostgresTypes {\n  abstime = 'abstime',\n  bool = 'bool',\n  date = 'date',\n  daterange = 'daterange',\n  float4 = 'float4',\n  float8 = 'float8',\n  int2 = 'int2',\n  int4 = 'int4',\n  int4range = 'int4range',\n  int8 = 'int8',\n  int8range = 'int8range',\n  json = 'json',\n  jsonb = 'jsonb',\n  money = 'money',\n  numeric = 'numeric',\n  oid = 'oid',\n  reltime = 'reltime',\n  text = 'text',\n  time = 'time',\n  timestamp = 'timestamp',\n  timestamptz = 'timestamptz',\n  timetz = 'timetz',\n  tsrange = 'tsrange',\n  tstzrange = 'tstzrange',\n}\n\ntype Columns = {\n  name: string // the column name. eg: \"user_id\"\n  type: string // the column type. eg: \"uuid\"\n  flags?: string[] // any special flags for the column. eg: [\"key\"]\n  type_modifier?: number // the type modifier. eg: 4294967295\n}[]\n\ntype BaseValue = null | string | number | boolean\ntype RecordValue = BaseValue | BaseValue[]\n\ntype Record = {\n  [key: string]: RecordValue\n}\n\n/**\n * Takes an array of columns and an object of string values then converts each string value\n * to its mapped type.\n *\n * @param {{name: String, type: String}[]} columns\n * @param {Object} record\n * @param {Object} options The map of various options that can be applied to the mapper\n * @param {Array} options.skipTypes The array of types that should not be converted\n *\n * @example convertChangeData([{name: 'first_name', type: 'text'}, {name: 'age', type: 'int4'}], {first_name: 'Paul', age:'33'}, {})\n * //=>{ first_name: 'Paul', age: 33 }\n */\nexport const convertChangeData = (\n  columns: Columns,\n  record: Record,\n  options: { skipTypes?: string[] } = {}\n): Record => {\n  const skipTypes = options.skipTypes ?? []\n\n  return Object.keys(record).reduce((acc, rec_key) => {\n    acc[rec_key] = convertColumn(rec_key, columns, record, skipTypes)\n    return acc\n  }, {} as Record)\n}\n\n/**\n * Converts the value of an individual column.\n *\n * @param {String} columnName The column that you want to convert\n * @param {{name: String, type: String}[]} columns All of the columns\n * @param {Object} record The map of string values\n * @param {Array} skipTypes An array of types that should not be converted\n * @return {object} Useless information\n *\n * @example convertColumn('age', [{name: 'first_name', type: 'text'}, {name: 'age', type: 'int4'}], {first_name: 'Paul', age: '33'}, [])\n * //=> 33\n * @example convertColumn('age', [{name: 'first_name', type: 'text'}, {name: 'age', type: 'int4'}], {first_name: 'Paul', age: '33'}, ['int4'])\n * //=> \"33\"\n */\nexport const convertColumn = (\n  columnName: string,\n  columns: Columns,\n  record: Record,\n  skipTypes: string[]\n): RecordValue => {\n  const column = columns.find((x) => x.name === columnName)\n  const colType = column?.type\n  const value = record[columnName]\n\n  if (colType && !skipTypes.includes(colType)) {\n    return convertCell(colType, value)\n  }\n\n  return noop(value)\n}\n\n/**\n * If the value of the cell is `null`, returns null.\n * Otherwise converts the string value to the correct type.\n * @param {String} type A postgres column type\n * @param {String} value The cell value\n *\n * @example convertCell('bool', 't')\n * //=> true\n * @example convertCell('int8', '10')\n * //=> 10\n * @example convertCell('_int4', '{1,2,3,4}')\n * //=> [1,2,3,4]\n */\nexport const convertCell = (type: string, value: RecordValue): RecordValue => {\n  // if data type is an array\n  if (type.charAt(0) === '_') {\n    const dataType = type.slice(1, type.length)\n    return toArray(value, dataType)\n  }\n\n  // If not null, convert to correct type.\n  switch (type) {\n    case PostgresTypes.bool:\n      return toBoolean(value)\n    case PostgresTypes.float4:\n    case PostgresTypes.float8:\n    case PostgresTypes.int2:\n    case PostgresTypes.int4:\n    case PostgresTypes.int8:\n    case PostgresTypes.numeric:\n    case PostgresTypes.oid:\n      return toNumber(value)\n    case PostgresTypes.json:\n    case PostgresTypes.jsonb:\n      return toJson(value)\n    case PostgresTypes.timestamp:\n      return toTimestampString(value) // Format to be consistent with PostgREST\n    case PostgresTypes.abstime: // To allow users to cast it based on Timezone\n    case PostgresTypes.date: // To allow users to cast it based on Timezone\n    case PostgresTypes.daterange:\n    case PostgresTypes.int4range:\n    case PostgresTypes.int8range:\n    case PostgresTypes.money:\n    case PostgresTypes.reltime: // To allow users to cast it based on Timezone\n    case PostgresTypes.text:\n    case PostgresTypes.time: // To allow users to cast it based on Timezone\n    case PostgresTypes.timestamptz: // To allow users to cast it based on Timezone\n    case PostgresTypes.timetz: // To allow users to cast it based on Timezone\n    case PostgresTypes.tsrange:\n    case PostgresTypes.tstzrange:\n      return noop(value)\n    default:\n      // Return the value for remaining types\n      return noop(value)\n  }\n}\n\nconst noop = (value: RecordValue): RecordValue => {\n  return value\n}\nexport const toBoolean = (value: RecordValue): RecordValue => {\n  switch (value) {\n    case 't':\n      return true\n    case 'f':\n      return false\n    default:\n      return value\n  }\n}\nexport const toNumber = (value: RecordValue): RecordValue => {\n  if (typeof value === 'string') {\n    const parsedValue = parseFloat(value)\n    if (!Number.isNaN(parsedValue)) {\n      return parsedValue\n    }\n  }\n  return value\n}\nexport const toJson = (value: RecordValue): RecordValue => {\n  if (typeof value === 'string') {\n    try {\n      return JSON.parse(value)\n    } catch (error) {\n      console.log(`JSON parse error: ${error}`)\n      return value\n    }\n  }\n  return value\n}\n\n/**\n * Converts a Postgres Array into a native JS array\n *\n * @example toArray('{}', 'int4')\n * //=> []\n * @example toArray('{\"[2021-01-01,2021-12-31)\",\"(2021-01-01,2021-12-32]\"}', 'daterange')\n * //=> ['[2021-01-01,2021-12-31)', '(2021-01-01,2021-12-32]']\n * @example toArray([1,2,3,4], 'int4')\n * //=> [1,2,3,4]\n */\nexport const toArray = (value: RecordValue, type: string): RecordValue => {\n  if (typeof value !== 'string') {\n    return value\n  }\n\n  const lastIdx = value.length - 1\n  const closeBrace = value[lastIdx]\n  const openBrace = value[0]\n\n  // Confirm value is a Postgres array by checking curly brackets\n  if (openBrace === '{' && closeBrace === '}') {\n    let arr\n    const valTrim = value.slice(1, lastIdx)\n\n    // TODO: find a better solution to separate Postgres array data\n    try {\n      arr = JSON.parse('[' + valTrim + ']')\n    } catch (_) {\n      // WARNING: splitting on comma does not cover all edge cases\n      arr = valTrim ? valTrim.split(',') : []\n    }\n\n    return arr.map((val: BaseValue) => convertCell(type, val))\n  }\n\n  return value\n}\n\n/**\n * Fixes timestamp to be ISO-8601. Swaps the space between the date and time for a 'T'\n * See https://github.com/supabase/supabase/issues/18\n *\n * @example toTimestampString('2019-09-10 00:00:00')\n * //=> '2019-09-10T00:00:00'\n */\nexport const toTimestampString = (value: RecordValue): RecordValue => {\n  if (typeof value === 'string') {\n    return value.replace(' ', 'T')\n  }\n\n  return value\n}\n\nexport const httpEndpointURL = (socketUrl: string): string => {\n  let url = socketUrl\n  url = url.replace(/^ws/i, 'http')\n  url = url.replace(/(\\/socket\\/websocket|\\/socket|\\/websocket)\\/?$/i, '')\n  return url.replace(/\\/+$/, '')\n}\n", "import { DEFAULT_TIMEOUT } from '../lib/constants'\nimport type RealtimeChannel from '../RealtimeChannel'\n\nexport default class Push {\n  sent: boolean = false\n  timeoutTimer: number | undefined = undefined\n  ref: string = ''\n  receivedResp: {\n    status: string\n    response: { [key: string]: any }\n  } | null = null\n  recHooks: {\n    status: string\n    callback: Function\n  }[] = []\n  refEvent: string | null = null\n\n  /**\n   * Initializes the Push\n   *\n   * @param channel The Channel\n   * @param event The event, for example `\"phx_join\"`\n   * @param payload The payload, for example `{user_id: 123}`\n   * @param timeout The push timeout in milliseconds\n   */\n  constructor(\n    public channel: RealtimeChannel,\n    public event: string,\n    public payload: { [key: string]: any } = {},\n    public timeout: number = DEFAULT_TIMEOUT\n  ) {}\n\n  resend(timeout: number) {\n    this.timeout = timeout\n    this._cancelRefEvent()\n    this.ref = ''\n    this.refEvent = null\n    this.receivedResp = null\n    this.sent = false\n    this.send()\n  }\n\n  send() {\n    if (this._hasReceived('timeout')) {\n      return\n    }\n    this.startTimeout()\n    this.sent = true\n    this.channel.socket.push({\n      topic: this.channel.topic,\n      event: this.event,\n      payload: this.payload,\n      ref: this.ref,\n      join_ref: this.channel._joinRef(),\n    })\n  }\n\n  updatePayload(payload: { [key: string]: any }): void {\n    this.payload = { ...this.payload, ...payload }\n  }\n\n  receive(status: string, callback: Function) {\n    if (this._hasReceived(status)) {\n      callback(this.receivedResp?.response)\n    }\n\n    this.recHooks.push({ status, callback })\n    return this\n  }\n\n  startTimeout() {\n    if (this.timeoutTimer) {\n      return\n    }\n    this.ref = this.channel.socket._makeRef()\n    this.refEvent = this.channel._replyEventName(this.ref)\n\n    const callback = (payload: any) => {\n      this._cancelRefEvent()\n      this._cancelTimeout()\n      this.receivedResp = payload\n      this._matchReceive(payload)\n    }\n\n    this.channel._on(this.refEvent, {}, callback)\n\n    this.timeoutTimer = <any>setTimeout(() => {\n      this.trigger('timeout', {})\n    }, this.timeout)\n  }\n\n  trigger(status: string, response: any) {\n    if (this.refEvent)\n      this.channel._trigger(this.refEvent, { status, response })\n  }\n\n  destroy() {\n    this._cancelRefEvent()\n    this._cancelTimeout()\n  }\n\n  private _cancelRefEvent() {\n    if (!this.refEvent) {\n      return\n    }\n\n    this.channel._off(this.refEvent, {})\n  }\n\n  private _cancelTimeout() {\n    clearTimeout(this.timeoutTimer)\n    this.timeoutTimer = undefined\n  }\n\n  private _matchReceive({\n    status,\n    response,\n  }: {\n    status: string\n    response: Function\n  }) {\n    this.recHooks\n      .filter((h) => h.status === status)\n      .forEach((h) => h.callback(response))\n  }\n\n  private _hasReceived(status: string) {\n    return this.receivedResp && this.receivedResp.status === status\n  }\n}\n", "/*\n  This file draws heavily from https://github.com/phoenixframework/phoenix/blob/d344ec0a732ab4ee204215b31de69cf4be72e3bf/assets/js/phoenix/presence.js\n  License: https://github.com/phoenixframework/phoenix/blob/d344ec0a732ab4ee204215b31de69cf4be72e3bf/LICENSE.md\n*/\n\nimport type {\n  PresenceOpts,\n  PresenceOnJoinCallback,\n  PresenceOnLeaveCallback,\n} from 'phoenix'\nimport type RealtimeChannel from './RealtimeChannel'\n\ntype Presence<T extends { [key: string]: any } = {}> = {\n  presence_ref: string\n} & T\n\nexport type RealtimePresenceState<T extends { [key: string]: any } = {}> = {\n  [key: string]: Presence<T>[]\n}\n\nexport type RealtimePresenceJoinPayload<T extends { [key: string]: any }> = {\n  event: `${REALTIME_PRESENCE_LISTEN_EVENTS.JOIN}`\n  key: string\n  currentPresences: Presence<T>[]\n  newPresences: Presence<T>[]\n}\n\nexport type RealtimePresenceLeavePayload<T extends { [key: string]: any }> = {\n  event: `${REALTIME_PRESENCE_LISTEN_EVENTS.LEAVE}`\n  key: string\n  currentPresences: Presence<T>[]\n  leftPresences: Presence<T>[]\n}\n\nexport enum REALTIME_PRESENCE_LISTEN_EVENTS {\n  SYNC = 'sync',\n  JOIN = 'join',\n  LEAVE = 'leave',\n}\n\ntype PresenceDiff = {\n  joins: RealtimePresenceState\n  leaves: RealtimePresenceState\n}\n\ntype RawPresenceState = {\n  [key: string]: {\n    metas: {\n      phx_ref?: string\n      phx_ref_prev?: string\n      [key: string]: any\n    }[]\n  }\n}\n\ntype RawPresenceDiff = {\n  joins: RawPresenceState\n  leaves: RawPresenceState\n}\n\ntype PresenceChooser<T> = (key: string, presences: Presence[]) => T\n\nexport default class RealtimePresence {\n  state: RealtimePresenceState = {}\n  pendingDiffs: RawPresenceDiff[] = []\n  joinRef: string | null = null\n  enabled: boolean = false\n  caller: {\n    onJoin: PresenceOnJoinCallback\n    onLeave: PresenceOnLeaveCallback\n    onSync: () => void\n  } = {\n    onJoin: () => {},\n    onLeave: () => {},\n    onSync: () => {},\n  }\n\n  /**\n   * Initializes the Presence.\n   *\n   * @param channel - The RealtimeChannel\n   * @param opts - The options,\n   *        for example `{events: {state: 'state', diff: 'diff'}}`\n   */\n  constructor(public channel: RealtimeChannel, opts?: PresenceOpts) {\n    const events = opts?.events || {\n      state: 'presence_state',\n      diff: 'presence_diff',\n    }\n\n    this.channel._on(events.state, {}, (newState: RawPresenceState) => {\n      const { onJoin, onLeave, onSync } = this.caller\n\n      this.joinRef = this.channel._joinRef()\n\n      this.state = RealtimePresence.syncState(\n        this.state,\n        newState,\n        onJoin,\n        onLeave\n      )\n\n      this.pendingDiffs.forEach((diff) => {\n        this.state = RealtimePresence.syncDiff(\n          this.state,\n          diff,\n          onJoin,\n          onLeave\n        )\n      })\n\n      this.pendingDiffs = []\n\n      onSync()\n    })\n\n    this.channel._on(events.diff, {}, (diff: RawPresenceDiff) => {\n      const { onJoin, onLeave, onSync } = this.caller\n\n      if (this.inPendingSyncState()) {\n        this.pendingDiffs.push(diff)\n      } else {\n        this.state = RealtimePresence.syncDiff(\n          this.state,\n          diff,\n          onJoin,\n          onLeave\n        )\n\n        onSync()\n      }\n    })\n\n    this.onJoin((key, currentPresences, newPresences) => {\n      this.channel._trigger('presence', {\n        event: 'join',\n        key,\n        currentPresences,\n        newPresences,\n      })\n    })\n\n    this.onLeave((key, currentPresences, leftPresences) => {\n      this.channel._trigger('presence', {\n        event: 'leave',\n        key,\n        currentPresences,\n        leftPresences,\n      })\n    })\n\n    this.onSync(() => {\n      this.channel._trigger('presence', { event: 'sync' })\n    })\n  }\n\n  /**\n   * Used to sync the list of presences on the server with the\n   * client's state.\n   *\n   * An optional `onJoin` and `onLeave` callback can be provided to\n   * react to changes in the client's local presences across\n   * disconnects and reconnects with the server.\n   *\n   * @internal\n   */\n  private static syncState(\n    currentState: RealtimePresenceState,\n    newState: RawPresenceState | RealtimePresenceState,\n    onJoin: PresenceOnJoinCallback,\n    onLeave: PresenceOnLeaveCallback\n  ): RealtimePresenceState {\n    const state = this.cloneDeep(currentState)\n    const transformedState = this.transformState(newState)\n    const joins: RealtimePresenceState = {}\n    const leaves: RealtimePresenceState = {}\n\n    this.map(state, (key: string, presences: Presence[]) => {\n      if (!transformedState[key]) {\n        leaves[key] = presences\n      }\n    })\n\n    this.map(transformedState, (key, newPresences: Presence[]) => {\n      const currentPresences: Presence[] = state[key]\n\n      if (currentPresences) {\n        const newPresenceRefs = newPresences.map(\n          (m: Presence) => m.presence_ref\n        )\n        const curPresenceRefs = currentPresences.map(\n          (m: Presence) => m.presence_ref\n        )\n        const joinedPresences: Presence[] = newPresences.filter(\n          (m: Presence) => curPresenceRefs.indexOf(m.presence_ref) < 0\n        )\n        const leftPresences: Presence[] = currentPresences.filter(\n          (m: Presence) => newPresenceRefs.indexOf(m.presence_ref) < 0\n        )\n\n        if (joinedPresences.length > 0) {\n          joins[key] = joinedPresences\n        }\n\n        if (leftPresences.length > 0) {\n          leaves[key] = leftPresences\n        }\n      } else {\n        joins[key] = newPresences\n      }\n    })\n\n    return this.syncDiff(state, { joins, leaves }, onJoin, onLeave)\n  }\n\n  /**\n   * Used to sync a diff of presence join and leave events from the\n   * server, as they happen.\n   *\n   * Like `syncState`, `syncDiff` accepts optional `onJoin` and\n   * `onLeave` callbacks to react to a user joining or leaving from a\n   * device.\n   *\n   * @internal\n   */\n  private static syncDiff(\n    state: RealtimePresenceState,\n    diff: RawPresenceDiff | PresenceDiff,\n    onJoin: PresenceOnJoinCallback,\n    onLeave: PresenceOnLeaveCallback\n  ): RealtimePresenceState {\n    const { joins, leaves } = {\n      joins: this.transformState(diff.joins),\n      leaves: this.transformState(diff.leaves),\n    }\n\n    if (!onJoin) {\n      onJoin = () => {}\n    }\n\n    if (!onLeave) {\n      onLeave = () => {}\n    }\n\n    this.map(joins, (key, newPresences: Presence[]) => {\n      const currentPresences: Presence[] = state[key] ?? []\n      state[key] = this.cloneDeep(newPresences)\n\n      if (currentPresences.length > 0) {\n        const joinedPresenceRefs = state[key].map(\n          (m: Presence) => m.presence_ref\n        )\n        const curPresences: Presence[] = currentPresences.filter(\n          (m: Presence) => joinedPresenceRefs.indexOf(m.presence_ref) < 0\n        )\n\n        state[key].unshift(...curPresences)\n      }\n\n      onJoin(key, currentPresences, newPresences)\n    })\n\n    this.map(leaves, (key, leftPresences: Presence[]) => {\n      let currentPresences: Presence[] = state[key]\n\n      if (!currentPresences) return\n\n      const presenceRefsToRemove = leftPresences.map(\n        (m: Presence) => m.presence_ref\n      )\n      currentPresences = currentPresences.filter(\n        (m: Presence) => presenceRefsToRemove.indexOf(m.presence_ref) < 0\n      )\n\n      state[key] = currentPresences\n\n      onLeave(key, currentPresences, leftPresences)\n\n      if (currentPresences.length === 0) delete state[key]\n    })\n\n    return state\n  }\n\n  /** @internal */\n  private static map<T = any>(\n    obj: RealtimePresenceState,\n    func: PresenceChooser<T>\n  ): T[] {\n    return Object.getOwnPropertyNames(obj).map((key) => func(key, obj[key]))\n  }\n\n  /**\n   * Remove 'metas' key\n   * Change 'phx_ref' to 'presence_ref'\n   * Remove 'phx_ref' and 'phx_ref_prev'\n   *\n   * @example\n   * // returns {\n   *  abc123: [\n   *    { presence_ref: '2', user_id: 1 },\n   *    { presence_ref: '3', user_id: 2 }\n   *  ]\n   * }\n   * RealtimePresence.transformState({\n   *  abc123: {\n   *    metas: [\n   *      { phx_ref: '2', phx_ref_prev: '1' user_id: 1 },\n   *      { phx_ref: '3', user_id: 2 }\n   *    ]\n   *  }\n   * })\n   *\n   * @internal\n   */\n  private static transformState(\n    state: RawPresenceState | RealtimePresenceState\n  ): RealtimePresenceState {\n    state = this.cloneDeep(state)\n\n    return Object.getOwnPropertyNames(state).reduce((newState, key) => {\n      const presences = state[key]\n\n      if ('metas' in presences) {\n        newState[key] = presences.metas.map((presence) => {\n          presence['presence_ref'] = presence['phx_ref']\n\n          delete presence['phx_ref']\n          delete presence['phx_ref_prev']\n\n          return presence\n        }) as Presence[]\n      } else {\n        newState[key] = presences\n      }\n\n      return newState\n    }, {} as RealtimePresenceState)\n  }\n\n  /** @internal */\n  private static cloneDeep(obj: { [key: string]: any }) {\n    return JSON.parse(JSON.stringify(obj))\n  }\n\n  /** @internal */\n  private onJoin(callback: PresenceOnJoinCallback): void {\n    this.caller.onJoin = callback\n  }\n\n  /** @internal */\n  private onLeave(callback: PresenceOnLeaveCallback): void {\n    this.caller.onLeave = callback\n  }\n\n  /** @internal */\n  private onSync(callback: () => void): void {\n    this.caller.onSync = callback\n  }\n\n  /** @internal */\n  private inPendingSyncState(): boolean {\n    return !this.joinRef || this.joinRef !== this.channel._joinRef()\n  }\n}\n", "import { CHANNEL_EVENTS, CHANNEL_STATES } from './lib/constants'\nimport Push from './lib/push'\nimport type RealtimeClient from './RealtimeClient'\nimport Timer from './lib/timer'\nimport RealtimePresence, {\n  REALTIME_PRESENCE_LISTEN_EVENTS,\n} from './RealtimePresence'\nimport type {\n  RealtimePresenceJoinPayload,\n  RealtimePresenceLeavePayload,\n  RealtimePresenceState,\n} from './RealtimePresence'\nimport * as Transformers from './lib/transformers'\nimport { httpEndpointURL } from './lib/transformers'\n\nexport type RealtimeChannelOptions = {\n  config: {\n    /**\n     * self option enables client to receive message it broadcast\n     * ack option instructs server to acknowledge that broadcast message was received\n     */\n    broadcast?: { self?: boolean; ack?: boolean }\n    /**\n     * key option is used to track presence payload across clients\n     */\n    presence?: { key?: string; enabled?: boolean }\n    /**\n     * defines if the channel is private or not and if RLS policies will be used to check data\n     */\n    private?: boolean\n  }\n}\n\ntype RealtimePostgresChangesPayloadBase = {\n  schema: string\n  table: string\n  commit_timestamp: string\n  errors: string[]\n}\n\nexport type RealtimePostgresInsertPayload<T extends { [key: string]: any }> =\n  RealtimePostgresChangesPayloadBase & {\n    eventType: `${REALTIME_POSTGRES_CHANGES_LISTEN_EVENT.INSERT}`\n    new: T\n    old: {}\n  }\n\nexport type RealtimePostgresUpdatePayload<T extends { [key: string]: any }> =\n  RealtimePostgresChangesPayloadBase & {\n    eventType: `${REALTIME_POSTGRES_CHANGES_LISTEN_EVENT.UPDATE}`\n    new: T\n    old: Partial<T>\n  }\n\nexport type RealtimePostgresDeletePayload<T extends { [key: string]: any }> =\n  RealtimePostgresChangesPayloadBase & {\n    eventType: `${REALTIME_POSTGRES_CHANGES_LISTEN_EVENT.DELETE}`\n    new: {}\n    old: Partial<T>\n  }\n\nexport type RealtimePostgresChangesPayload<T extends { [key: string]: any }> =\n  | RealtimePostgresInsertPayload<T>\n  | RealtimePostgresUpdatePayload<T>\n  | RealtimePostgresDeletePayload<T>\n\nexport type RealtimePostgresChangesFilter<\n  T extends `${REALTIME_POSTGRES_CHANGES_LISTEN_EVENT}`\n> = {\n  /**\n   * The type of database change to listen to.\n   */\n  event: T\n  /**\n   * The database schema to listen to.\n   */\n  schema: string\n  /**\n   * The database table to listen to.\n   */\n  table?: string\n  /**\n   * Receive database changes when filter is matched.\n   */\n  filter?: string\n}\n\nexport type RealtimeChannelSendResponse = 'ok' | 'timed out' | 'error'\n\nexport enum REALTIME_POSTGRES_CHANGES_LISTEN_EVENT {\n  ALL = '*',\n  INSERT = 'INSERT',\n  UPDATE = 'UPDATE',\n  DELETE = 'DELETE',\n}\n\nexport enum REALTIME_LISTEN_TYPES {\n  BROADCAST = 'broadcast',\n  PRESENCE = 'presence',\n  POSTGRES_CHANGES = 'postgres_changes',\n  SYSTEM = 'system',\n}\n\nexport enum REALTIME_SUBSCRIBE_STATES {\n  SUBSCRIBED = 'SUBSCRIBED',\n  TIMED_OUT = 'TIMED_OUT',\n  CLOSED = 'CLOSED',\n  CHANNEL_ERROR = 'CHANNEL_ERROR',\n}\n\nexport const REALTIME_CHANNEL_STATES = CHANNEL_STATES\n\ninterface PostgresChangesFilters {\n  postgres_changes: {\n    id: string\n    event: string\n    schema?: string\n    table?: string\n    filter?: string\n  }[]\n}\n/** A channel is the basic building block of Realtime\n * and narrows the scope of data flow to subscribed clients.\n * You can think of a channel as a chatroom where participants are able to see who's online\n * and send and receive messages.\n */\nexport default class RealtimeChannel {\n  bindings: {\n    [key: string]: {\n      type: string\n      filter: { [key: string]: any }\n      callback: Function\n      id?: string\n    }[]\n  } = {}\n  timeout: number\n  state: CHANNEL_STATES = CHANNEL_STATES.closed\n  joinedOnce = false\n  joinPush: Push\n  rejoinTimer: Timer\n  pushBuffer: Push[] = []\n  presence: RealtimePresence\n  broadcastEndpointURL: string\n  subTopic: string\n  private: boolean\n\n  constructor(\n    /** Topic name can be any string. */\n    public topic: string,\n    public params: RealtimeChannelOptions = { config: {} },\n    public socket: RealtimeClient\n  ) {\n    this.subTopic = topic.replace(/^realtime:/i, '')\n    this.params.config = {\n      ...{\n        broadcast: { ack: false, self: false },\n        presence: { key: '', enabled: false },\n        private: false,\n      },\n      ...params.config,\n    }\n    this.timeout = this.socket.timeout\n    this.joinPush = new Push(\n      this,\n      CHANNEL_EVENTS.join,\n      this.params,\n      this.timeout\n    )\n    this.rejoinTimer = new Timer(\n      () => this._rejoinUntilConnected(),\n      this.socket.reconnectAfterMs\n    )\n    this.joinPush.receive('ok', () => {\n      this.state = CHANNEL_STATES.joined\n      this.rejoinTimer.reset()\n      this.pushBuffer.forEach((pushEvent: Push) => pushEvent.send())\n      this.pushBuffer = []\n    })\n    this._onClose(() => {\n      this.rejoinTimer.reset()\n      this.socket.log('channel', `close ${this.topic} ${this._joinRef()}`)\n      this.state = CHANNEL_STATES.closed\n      this.socket._remove(this)\n    })\n    this._onError((reason: string) => {\n      if (this._isLeaving() || this._isClosed()) {\n        return\n      }\n      this.socket.log('channel', `error ${this.topic}`, reason)\n      this.state = CHANNEL_STATES.errored\n      this.rejoinTimer.scheduleTimeout()\n    })\n    this.joinPush.receive('timeout', () => {\n      if (!this._isJoining()) {\n        return\n      }\n      this.socket.log('channel', `timeout ${this.topic}`, this.joinPush.timeout)\n      this.state = CHANNEL_STATES.errored\n      this.rejoinTimer.scheduleTimeout()\n    })\n    this._on(CHANNEL_EVENTS.reply, {}, (payload: any, ref: string) => {\n      this._trigger(this._replyEventName(ref), payload)\n    })\n\n    this.presence = new RealtimePresence(this)\n\n    this.broadcastEndpointURL =\n      httpEndpointURL(this.socket.endPoint) + '/api/broadcast'\n    this.private = this.params.config.private || false\n  }\n\n  /** Subscribe registers your client with the server */\n  subscribe(\n    callback?: (status: REALTIME_SUBSCRIBE_STATES, err?: Error) => void,\n    timeout = this.timeout\n  ): RealtimeChannel {\n    if (!this.socket.isConnected()) {\n      this.socket.connect()\n    }\n    if (this.state == CHANNEL_STATES.closed) {\n      const {\n        config: { broadcast, presence, private: isPrivate },\n      } = this.params\n\n      const postgres_changes =\n        this.bindings.postgres_changes?.map((r) => r.filter) ?? []\n\n      const presence_enabled = !!this.bindings[REALTIME_LISTEN_TYPES.PRESENCE]\n      const accessTokenPayload: { access_token?: string } = {}\n      const config = {\n        broadcast,\n        presence: { ...presence, enabled: presence_enabled },\n        postgres_changes,\n        private: isPrivate,\n      }\n\n      if (this.socket.accessTokenValue) {\n        accessTokenPayload.access_token = this.socket.accessTokenValue\n      }\n\n      this._onError((e: Error) =>\n        callback?.(REALTIME_SUBSCRIBE_STATES.CHANNEL_ERROR, e)\n      )\n\n      this._onClose(() => callback?.(REALTIME_SUBSCRIBE_STATES.CLOSED))\n\n      this.updateJoinPayload({ ...{ config }, ...accessTokenPayload })\n\n      this.joinedOnce = true\n      this._rejoin(timeout)\n\n      this.joinPush\n        .receive('ok', async ({ postgres_changes }: PostgresChangesFilters) => {\n          this.socket.setAuth()\n          if (postgres_changes === undefined) {\n            callback?.(REALTIME_SUBSCRIBE_STATES.SUBSCRIBED)\n            return\n          } else {\n            const clientPostgresBindings = this.bindings.postgres_changes\n            const bindingsLen = clientPostgresBindings?.length ?? 0\n            const newPostgresBindings = []\n\n            for (let i = 0; i < bindingsLen; i++) {\n              const clientPostgresBinding = clientPostgresBindings[i]\n              const {\n                filter: { event, schema, table, filter },\n              } = clientPostgresBinding\n              const serverPostgresFilter =\n                postgres_changes && postgres_changes[i]\n\n              if (\n                serverPostgresFilter &&\n                serverPostgresFilter.event === event &&\n                serverPostgresFilter.schema === schema &&\n                serverPostgresFilter.table === table &&\n                serverPostgresFilter.filter === filter\n              ) {\n                newPostgresBindings.push({\n                  ...clientPostgresBinding,\n                  id: serverPostgresFilter.id,\n                })\n              } else {\n                this.unsubscribe()\n                this.state = CHANNEL_STATES.errored\n\n                callback?.(\n                  REALTIME_SUBSCRIBE_STATES.CHANNEL_ERROR,\n                  new Error(\n                    'mismatch between server and client bindings for postgres changes'\n                  )\n                )\n                return\n              }\n            }\n\n            this.bindings.postgres_changes = newPostgresBindings\n\n            callback && callback(REALTIME_SUBSCRIBE_STATES.SUBSCRIBED)\n            return\n          }\n        })\n        .receive('error', (error: { [key: string]: any }) => {\n          this.state = CHANNEL_STATES.errored\n          callback?.(\n            REALTIME_SUBSCRIBE_STATES.CHANNEL_ERROR,\n            new Error(\n              JSON.stringify(Object.values(error).join(', ') || 'error')\n            )\n          )\n          return\n        })\n        .receive('timeout', () => {\n          callback?.(REALTIME_SUBSCRIBE_STATES.TIMED_OUT)\n          return\n        })\n    }\n    return this\n  }\n\n  presenceState<\n    T extends { [key: string]: any } = {}\n  >(): RealtimePresenceState<T> {\n    return this.presence.state as RealtimePresenceState<T>\n  }\n\n  async track(\n    payload: { [key: string]: any },\n    opts: { [key: string]: any } = {}\n  ): Promise<RealtimeChannelSendResponse> {\n    return await this.send(\n      {\n        type: 'presence',\n        event: 'track',\n        payload,\n      },\n      opts.timeout || this.timeout\n    )\n  }\n\n  async untrack(\n    opts: { [key: string]: any } = {}\n  ): Promise<RealtimeChannelSendResponse> {\n    return await this.send(\n      {\n        type: 'presence',\n        event: 'untrack',\n      },\n      opts\n    )\n  }\n\n  /**\n   * Creates an event handler that listens to changes.\n   */\n  on(\n    type: `${REALTIME_LISTEN_TYPES.PRESENCE}`,\n    filter: { event: `${REALTIME_PRESENCE_LISTEN_EVENTS.SYNC}` },\n    callback: () => void\n  ): RealtimeChannel\n  on<T extends { [key: string]: any }>(\n    type: `${REALTIME_LISTEN_TYPES.PRESENCE}`,\n    filter: { event: `${REALTIME_PRESENCE_LISTEN_EVENTS.JOIN}` },\n    callback: (payload: RealtimePresenceJoinPayload<T>) => void\n  ): RealtimeChannel\n  on<T extends { [key: string]: any }>(\n    type: `${REALTIME_LISTEN_TYPES.PRESENCE}`,\n    filter: { event: `${REALTIME_PRESENCE_LISTEN_EVENTS.LEAVE}` },\n    callback: (payload: RealtimePresenceLeavePayload<T>) => void\n  ): RealtimeChannel\n  on<T extends { [key: string]: any }>(\n    type: `${REALTIME_LISTEN_TYPES.POSTGRES_CHANGES}`,\n    filter: RealtimePostgresChangesFilter<`${REALTIME_POSTGRES_CHANGES_LISTEN_EVENT.ALL}`>,\n    callback: (payload: RealtimePostgresChangesPayload<T>) => void\n  ): RealtimeChannel\n  on<T extends { [key: string]: any }>(\n    type: `${REALTIME_LISTEN_TYPES.POSTGRES_CHANGES}`,\n    filter: RealtimePostgresChangesFilter<`${REALTIME_POSTGRES_CHANGES_LISTEN_EVENT.INSERT}`>,\n    callback: (payload: RealtimePostgresInsertPayload<T>) => void\n  ): RealtimeChannel\n  on<T extends { [key: string]: any }>(\n    type: `${REALTIME_LISTEN_TYPES.POSTGRES_CHANGES}`,\n    filter: RealtimePostgresChangesFilter<`${REALTIME_POSTGRES_CHANGES_LISTEN_EVENT.UPDATE}`>,\n    callback: (payload: RealtimePostgresUpdatePayload<T>) => void\n  ): RealtimeChannel\n  on<T extends { [key: string]: any }>(\n    type: `${REALTIME_LISTEN_TYPES.POSTGRES_CHANGES}`,\n    filter: RealtimePostgresChangesFilter<`${REALTIME_POSTGRES_CHANGES_LISTEN_EVENT.DELETE}`>,\n    callback: (payload: RealtimePostgresDeletePayload<T>) => void\n  ): RealtimeChannel\n  /**\n   * The following is placed here to display on supabase.com/docs/reference/javascript/subscribe.\n   * @param type One of \"broadcast\", \"presence\", or \"postgres_changes\".\n   * @param filter Custom object specific to the Realtime feature detailing which payloads to receive.\n   * @param callback Function to be invoked when event handler is triggered.\n   */\n  on(\n    type: `${REALTIME_LISTEN_TYPES.BROADCAST}`,\n    filter: { event: string },\n    callback: (payload: {\n      type: `${REALTIME_LISTEN_TYPES.BROADCAST}`\n      event: string\n      [key: string]: any\n    }) => void\n  ): RealtimeChannel\n  on<T extends { [key: string]: any }>(\n    type: `${REALTIME_LISTEN_TYPES.BROADCAST}`,\n    filter: { event: string },\n    callback: (payload: {\n      type: `${REALTIME_LISTEN_TYPES.BROADCAST}`\n      event: string\n      payload: T\n    }) => void\n  ): RealtimeChannel\n  on<T extends { [key: string]: any }>(\n    type: `${REALTIME_LISTEN_TYPES.SYSTEM}`,\n    filter: {},\n    callback: (payload: any) => void\n  ): RealtimeChannel\n  on(\n    type: `${REALTIME_LISTEN_TYPES}`,\n    filter: { event: string; [key: string]: string },\n    callback: (payload: any) => void\n  ): RealtimeChannel {\n    if (\n      this.state === CHANNEL_STATES.joined &&\n      type === REALTIME_LISTEN_TYPES.PRESENCE\n    ) {\n      this.socket.log(\n        'channel',\n        `resubscribe to ${this.topic} due to change in presence callbacks on joined channel`\n      )\n      this.unsubscribe().then(() => this.subscribe())\n    }\n    return this._on(type, filter, callback)\n  }\n  /**\n   * Sends a message into the channel.\n   *\n   * @param args Arguments to send to channel\n   * @param args.type The type of event to send\n   * @param args.event The name of the event being sent\n   * @param args.payload Payload to be sent\n   * @param opts Options to be used during the send process\n   */\n  async send(\n    args: {\n      type: 'broadcast' | 'presence' | 'postgres_changes'\n      event: string\n      payload?: any\n      [key: string]: any\n    },\n    opts: { [key: string]: any } = {}\n  ): Promise<RealtimeChannelSendResponse> {\n    if (!this._canPush() && args.type === 'broadcast') {\n      const { event, payload: endpoint_payload } = args\n      const authorization = this.socket.accessTokenValue\n        ? `Bearer ${this.socket.accessTokenValue}`\n        : ''\n      const options = {\n        method: 'POST',\n        headers: {\n          Authorization: authorization,\n          apikey: this.socket.apiKey ? this.socket.apiKey : '',\n          'Content-Type': 'application/json',\n        },\n        body: JSON.stringify({\n          messages: [\n            {\n              topic: this.subTopic,\n              event,\n              payload: endpoint_payload,\n              private: this.private,\n            },\n          ],\n        }),\n      }\n\n      try {\n        const response = await this._fetchWithTimeout(\n          this.broadcastEndpointURL,\n          options,\n          opts.timeout ?? this.timeout\n        )\n\n        await response.body?.cancel()\n        return response.ok ? 'ok' : 'error'\n      } catch (error: any) {\n        if (error.name === 'AbortError') {\n          return 'timed out'\n        } else {\n          return 'error'\n        }\n      }\n    } else {\n      return new Promise((resolve) => {\n        const push = this._push(args.type, args, opts.timeout || this.timeout)\n\n        if (args.type === 'broadcast' && !this.params?.config?.broadcast?.ack) {\n          resolve('ok')\n        }\n\n        push.receive('ok', () => resolve('ok'))\n        push.receive('error', () => resolve('error'))\n        push.receive('timeout', () => resolve('timed out'))\n      })\n    }\n  }\n\n  updateJoinPayload(payload: { [key: string]: any }): void {\n    this.joinPush.updatePayload(payload)\n  }\n\n  /**\n   * Leaves the channel.\n   *\n   * Unsubscribes from server events, and instructs channel to terminate on server.\n   * Triggers onClose() hooks.\n   *\n   * To receive leave acknowledgements, use the a `receive` hook to bind to the server ack, ie:\n   * channel.unsubscribe().receive(\"ok\", () => alert(\"left!\") )\n   */\n  unsubscribe(timeout = this.timeout): Promise<'ok' | 'timed out' | 'error'> {\n    this.state = CHANNEL_STATES.leaving\n    const onClose = () => {\n      this.socket.log('channel', `leave ${this.topic}`)\n      this._trigger(CHANNEL_EVENTS.close, 'leave', this._joinRef())\n    }\n\n    this.joinPush.destroy()\n\n    let leavePush: Push | null = null\n\n    return new Promise<RealtimeChannelSendResponse>((resolve) => {\n      leavePush = new Push(this, CHANNEL_EVENTS.leave, {}, timeout)\n      leavePush\n        .receive('ok', () => {\n          onClose()\n          resolve('ok')\n        })\n        .receive('timeout', () => {\n          onClose()\n          resolve('timed out')\n        })\n        .receive('error', () => {\n          resolve('error')\n        })\n\n      leavePush.send()\n      if (!this._canPush()) {\n        leavePush.trigger('ok', {})\n      }\n    }).finally(() => {\n      leavePush?.destroy()\n    })\n  }\n  /**\n   * Teardown the channel.\n   *\n   * Destroys and stops related timers.\n   */\n  teardown() {\n    this.pushBuffer.forEach((push: Push) => push.destroy())\n    this.rejoinTimer && clearTimeout(this.rejoinTimer.timer)\n    this.joinPush.destroy()\n  }\n\n  /** @internal */\n\n  async _fetchWithTimeout(\n    url: string,\n    options: { [key: string]: any },\n    timeout: number\n  ) {\n    const controller = new AbortController()\n    const id = setTimeout(() => controller.abort(), timeout)\n\n    const response = await this.socket.fetch(url, {\n      ...options,\n      signal: controller.signal,\n    })\n\n    clearTimeout(id)\n\n    return response\n  }\n\n  /** @internal */\n  _push(\n    event: string,\n    payload: { [key: string]: any },\n    timeout = this.timeout\n  ) {\n    if (!this.joinedOnce) {\n      throw `tried to push '${event}' to '${this.topic}' before joining. Use channel.subscribe() before pushing events`\n    }\n    let pushEvent = new Push(this, event, payload, timeout)\n    if (this._canPush()) {\n      pushEvent.send()\n    } else {\n      pushEvent.startTimeout()\n      this.pushBuffer.push(pushEvent)\n    }\n\n    return pushEvent\n  }\n\n  /**\n   * Overridable message hook\n   *\n   * Receives all events for specialized message handling before dispatching to the channel callbacks.\n   * Must return the payload, modified or unmodified.\n   *\n   * @internal\n   */\n  _onMessage(_event: string, payload: any, _ref?: string) {\n    return payload\n  }\n\n  /** @internal */\n  _isMember(topic: string): boolean {\n    return this.topic === topic\n  }\n\n  /** @internal */\n  _joinRef(): string {\n    return this.joinPush.ref\n  }\n\n  /** @internal */\n  _trigger(type: string, payload?: any, ref?: string) {\n    const typeLower = type.toLocaleLowerCase()\n    const { close, error, leave, join } = CHANNEL_EVENTS\n    const events: string[] = [close, error, leave, join]\n    if (ref && events.indexOf(typeLower) >= 0 && ref !== this._joinRef()) {\n      return\n    }\n    let handledPayload = this._onMessage(typeLower, payload, ref)\n    if (payload && !handledPayload) {\n      throw 'channel onMessage callbacks must return the payload, modified or unmodified'\n    }\n\n    if (['insert', 'update', 'delete'].includes(typeLower)) {\n      this.bindings.postgres_changes\n        ?.filter((bind) => {\n          return (\n            bind.filter?.event === '*' ||\n            bind.filter?.event?.toLocaleLowerCase() === typeLower\n          )\n        })\n        .map((bind) => bind.callback(handledPayload, ref))\n    } else {\n      this.bindings[typeLower]\n        ?.filter((bind) => {\n          if (\n            ['broadcast', 'presence', 'postgres_changes'].includes(typeLower)\n          ) {\n            if ('id' in bind) {\n              const bindId = bind.id\n              const bindEvent = bind.filter?.event\n              return (\n                bindId &&\n                payload.ids?.includes(bindId) &&\n                (bindEvent === '*' ||\n                  bindEvent?.toLocaleLowerCase() ===\n                    payload.data?.type.toLocaleLowerCase())\n              )\n            } else {\n              const bindEvent = bind?.filter?.event?.toLocaleLowerCase()\n              return (\n                bindEvent === '*' ||\n                bindEvent === payload?.event?.toLocaleLowerCase()\n              )\n            }\n          } else {\n            return bind.type.toLocaleLowerCase() === typeLower\n          }\n        })\n        .map((bind) => {\n          if (typeof handledPayload === 'object' && 'ids' in handledPayload) {\n            const postgresChanges = handledPayload.data\n            const { schema, table, commit_timestamp, type, errors } =\n              postgresChanges\n            const enrichedPayload = {\n              schema: schema,\n              table: table,\n              commit_timestamp: commit_timestamp,\n              eventType: type,\n              new: {},\n              old: {},\n              errors: errors,\n            }\n            handledPayload = {\n              ...enrichedPayload,\n              ...this._getPayloadRecords(postgresChanges),\n            }\n          }\n          bind.callback(handledPayload, ref)\n        })\n    }\n  }\n\n  /** @internal */\n  _isClosed(): boolean {\n    return this.state === CHANNEL_STATES.closed\n  }\n\n  /** @internal */\n  _isJoined(): boolean {\n    return this.state === CHANNEL_STATES.joined\n  }\n\n  /** @internal */\n  _isJoining(): boolean {\n    return this.state === CHANNEL_STATES.joining\n  }\n\n  /** @internal */\n  _isLeaving(): boolean {\n    return this.state === CHANNEL_STATES.leaving\n  }\n\n  /** @internal */\n  _replyEventName(ref: string): string {\n    return `chan_reply_${ref}`\n  }\n\n  /** @internal */\n  _on(type: string, filter: { [key: string]: any }, callback: Function) {\n    const typeLower = type.toLocaleLowerCase()\n    const binding = {\n      type: typeLower,\n      filter: filter,\n      callback: callback,\n    }\n\n    if (this.bindings[typeLower]) {\n      this.bindings[typeLower].push(binding)\n    } else {\n      this.bindings[typeLower] = [binding]\n    }\n\n    return this\n  }\n\n  /** @internal */\n  _off(type: string, filter: { [key: string]: any }) {\n    const typeLower = type.toLocaleLowerCase()\n\n    this.bindings[typeLower] = this.bindings[typeLower].filter((bind) => {\n      return !(\n        bind.type?.toLocaleLowerCase() === typeLower &&\n        RealtimeChannel.isEqual(bind.filter, filter)\n      )\n    })\n    return this\n  }\n\n  /** @internal */\n  private static isEqual(\n    obj1: { [key: string]: string },\n    obj2: { [key: string]: string }\n  ) {\n    if (Object.keys(obj1).length !== Object.keys(obj2).length) {\n      return false\n    }\n\n    for (const k in obj1) {\n      if (obj1[k] !== obj2[k]) {\n        return false\n      }\n    }\n\n    return true\n  }\n\n  /** @internal */\n  private _rejoinUntilConnected() {\n    this.rejoinTimer.scheduleTimeout()\n    if (this.socket.isConnected()) {\n      this._rejoin()\n    }\n  }\n\n  /**\n   * Registers a callback that will be executed when the channel closes.\n   *\n   * @internal\n   */\n  private _onClose(callback: Function) {\n    this._on(CHANNEL_EVENTS.close, {}, callback)\n  }\n\n  /**\n   * Registers a callback that will be executed when the channel encounteres an error.\n   *\n   * @internal\n   */\n  private _onError(callback: Function) {\n    this._on(CHANNEL_EVENTS.error, {}, (reason: string) => callback(reason))\n  }\n\n  /**\n   * Returns `true` if the socket is connected and the channel has been joined.\n   *\n   * @internal\n   */\n  private _canPush(): boolean {\n    return this.socket.isConnected() && this._isJoined()\n  }\n\n  /** @internal */\n  private _rejoin(timeout = this.timeout): void {\n    if (this._isLeaving()) {\n      return\n    }\n    this.socket._leaveOpenTopic(this.topic)\n    this.state = CHANNEL_STATES.joining\n    this.joinPush.resend(timeout)\n  }\n\n  /** @internal */\n  private _getPayloadRecords(payload: any) {\n    const records = {\n      new: {},\n      old: {},\n    }\n\n    if (payload.type === 'INSERT' || payload.type === 'UPDATE') {\n      records.new = Transformers.convertChangeData(\n        payload.columns,\n        payload.record\n      )\n    }\n\n    if (payload.type === 'UPDATE' || payload.type === 'DELETE') {\n      records.old = Transformers.convertChangeData(\n        payload.columns,\n        payload.old_record\n      )\n    }\n\n    return records\n  }\n}\n", "import { WebSocket } from 'isows'\n\nimport {\n  CHANNEL_EVENTS,\n  CONNECTION_STATE,\n  DEFAULT_VERSION,\n  DEFAULT_TIMEOUT,\n  SOCKET_STATES,\n  TRANSPORTS,\n  VSN,\n  WS_CLOSE_NORMAL,\n} from './lib/constants'\n\nimport Serializer from './lib/serializer'\nimport Timer from './lib/timer'\n\nimport { httpEndpointURL } from './lib/transformers'\nimport RealtimeChannel from './RealtimeChannel'\nimport type { RealtimeChannelOptions } from './RealtimeChannel'\n\ntype Fetch = typeof fetch\n\nexport type Channel = {\n  name: string\n  inserted_at: string\n  updated_at: string\n  id: number\n}\nexport type LogLevel = 'info' | 'warn' | 'error'\n\nexport type RealtimeMessage = {\n  topic: string\n  event: string\n  payload: any\n  ref: string\n  join_ref?: string\n}\n\nexport type RealtimeRemoveChannelResponse = 'ok' | 'timed out' | 'error'\nexport type HeartbeatStatus =\n  | 'sent'\n  | 'ok'\n  | 'error'\n  | 'timeout'\n  | 'disconnected'\n\nconst noop = () => {}\n\nexport interface WebSocketLikeConstructor {\n  new (\n    address: string | URL,\n    subprotocols?: string | string[] | undefined\n  ): WebSocketLike\n}\n\nexport type WebSocketLike = WebSocket\n\nexport interface WebSocketLikeError {\n  error: any\n  message: string\n  type: string\n}\n\nexport type RealtimeClientOptions = {\n  transport?: WebSocketLikeConstructor\n  timeout?: number\n  heartbeatIntervalMs?: number\n  logger?: Function\n  encode?: Function\n  decode?: Function\n  reconnectAfterMs?: Function\n  headers?: { [key: string]: string }\n  params?: { [key: string]: any }\n  //Deprecated: Use it in favour of correct casing `logLevel`\n  log_level?: LogLevel\n  logLevel?: LogLevel\n  fetch?: Fetch\n  worker?: boolean\n  workerUrl?: string\n  accessToken?: () => Promise<string | null>\n}\n\nconst WORKER_SCRIPT = `\n  addEventListener(\"message\", (e) => {\n    if (e.data.event === \"start\") {\n      setInterval(() => postMessage({ event: \"keepAlive\" }), e.data.interval);\n    }\n  });`\n\nexport default class RealtimeClient {\n  accessTokenValue: string | null = null\n  apiKey: string | null = null\n  channels: RealtimeChannel[] = new Array()\n  endPoint: string = ''\n  httpEndpoint: string = ''\n  /** @deprecated headers cannot be set on websocket connections */\n  headers?: { [key: string]: string } = {}\n  params?: { [key: string]: string } = {}\n  timeout: number = DEFAULT_TIMEOUT\n  transport: WebSocketLikeConstructor | null\n  heartbeatIntervalMs: number = 25000\n  heartbeatTimer: ReturnType<typeof setInterval> | undefined = undefined\n  pendingHeartbeatRef: string | null = null\n  heartbeatCallback: (status: HeartbeatStatus) => void = noop\n  ref: number = 0\n  reconnectTimer: Timer\n  logger: Function = noop\n  logLevel?: LogLevel\n  encode: Function\n  decode: Function\n  reconnectAfterMs: Function\n  conn: WebSocketLike | null = null\n  sendBuffer: Function[] = []\n  serializer: Serializer = new Serializer()\n  stateChangeCallbacks: {\n    open: Function[]\n    close: Function[]\n    error: Function[]\n    message: Function[]\n  } = {\n    open: [],\n    close: [],\n    error: [],\n    message: [],\n  }\n  fetch: Fetch\n  accessToken: (() => Promise<string | null>) | null = null\n  worker?: boolean\n  workerUrl?: string\n  workerRef?: Worker\n\n  /**\n   * Initializes the Socket.\n   *\n   * @param endPoint The string WebSocket endpoint, ie, \"ws://example.com/socket\", \"wss://example.com\", \"/socket\" (inherited host & protocol)\n   * @param httpEndpoint The string HTTP endpoint, ie, \"https://example.com\", \"/\" (inherited host & protocol)\n   * @param options.transport The Websocket Transport, for example WebSocket. This can be a custom implementation\n   * @param options.timeout The default timeout in milliseconds to trigger push timeouts.\n   * @param options.params The optional params to pass when connecting.\n   * @param options.headers Deprecated: headers cannot be set on websocket connections and this option will be removed in the future.\n   * @param options.heartbeatIntervalMs The millisec interval to send a heartbeat message.\n   * @param options.logger The optional function for specialized logging, ie: logger: (kind, msg, data) => { console.log(`${kind}: ${msg}`, data) }\n   * @param options.logLevel Sets the log level for Realtime\n   * @param options.encode The function to encode outgoing messages. Defaults to JSON: (payload, callback) => callback(JSON.stringify(payload))\n   * @param options.decode The function to decode incoming messages. Defaults to Serializer's decode.\n   * @param options.reconnectAfterMs he optional function that returns the millsec reconnect interval. Defaults to stepped backoff off.\n   * @param options.worker Use Web Worker to set a side flow. Defaults to false.\n   * @param options.workerUrl The URL of the worker script. Defaults to https://realtime.supabase.com/worker.js that includes a heartbeat event call to keep the connection alive.\n   */\n  constructor(endPoint: string, options?: RealtimeClientOptions) {\n    this.endPoint = `${endPoint}/${TRANSPORTS.websocket}`\n    this.httpEndpoint = httpEndpointURL(endPoint)\n    if (options?.transport) {\n      this.transport = options.transport\n    } else {\n      this.transport = null\n    }\n    if (options?.params) this.params = options.params\n    if (options?.timeout) this.timeout = options.timeout\n    if (options?.logger) this.logger = options.logger\n    if (options?.logLevel || options?.log_level) {\n      this.logLevel = options.logLevel || options.log_level\n      this.params = { ...this.params, log_level: this.logLevel as string }\n    }\n\n    if (options?.heartbeatIntervalMs)\n      this.heartbeatIntervalMs = options.heartbeatIntervalMs\n\n    const accessTokenValue = options?.params?.apikey\n    if (accessTokenValue) {\n      this.accessTokenValue = accessTokenValue\n      this.apiKey = accessTokenValue\n    }\n\n    this.reconnectAfterMs = options?.reconnectAfterMs\n      ? options.reconnectAfterMs\n      : (tries: number) => {\n          return [1000, 2000, 5000, 10000][tries - 1] || 10000\n        }\n    this.encode = options?.encode\n      ? options.encode\n      : (payload: JSON, callback: Function) => {\n          return callback(JSON.stringify(payload))\n        }\n    this.decode = options?.decode\n      ? options.decode\n      : this.serializer.decode.bind(this.serializer)\n    this.reconnectTimer = new Timer(async () => {\n      this.disconnect()\n      this.connect()\n    }, this.reconnectAfterMs)\n\n    this.fetch = this._resolveFetch(options?.fetch)\n    if (options?.worker) {\n      if (typeof window !== 'undefined' && !window.Worker) {\n        throw new Error('Web Worker is not supported')\n      }\n      this.worker = options?.worker || false\n      this.workerUrl = options?.workerUrl\n    }\n    this.accessToken = options?.accessToken || null\n  }\n\n  /**\n   * Connects the socket, unless already connected.\n   */\n  connect(): void {\n    // Set the token on connect\n    setTimeout(() => {\n      this.setAuth().catch((e) => {\n        this.log('error', 'error setting auth', e)\n      })\n    }, 0)\n    if (this.conn) {\n      return\n    }\n    if (!this.transport) {\n      this.transport = WebSocket\n    }\n    if (!this.transport) {\n      throw new Error('No transport provided')\n    }\n    this.conn = new this.transport(this.endpointURL()) as WebSocketLike\n    this.setupConnection()\n  }\n\n  /**\n   * Returns the URL of the websocket.\n   * @returns string The URL of the websocket.\n   */\n  endpointURL(): string {\n    return this._appendParams(\n      this.endPoint,\n      Object.assign({}, this.params, { vsn: VSN })\n    )\n  }\n\n  /**\n   * Disconnects the socket.\n   *\n   * @param code A numeric status code to send on disconnect.\n   * @param reason A custom reason for the disconnect.\n   */\n  disconnect(code?: number, reason?: string): void {\n    if (this.conn) {\n      this.conn.onclose = function () {} // noop\n      if (code) {\n        this.conn.close(code, reason ?? '')\n      } else {\n        this.conn.close()\n      }\n      this.conn = null\n\n      // remove open handles\n      this.heartbeatTimer && clearInterval(this.heartbeatTimer)\n      this.reconnectTimer.reset()\n      this.channels.forEach((channel) => channel.teardown())\n    }\n  }\n\n  /**\n   * Returns all created channels\n   */\n  getChannels(): RealtimeChannel[] {\n    return this.channels\n  }\n\n  /**\n   * Unsubscribes and removes a single channel\n   * @param channel A RealtimeChannel instance\n   */\n  async removeChannel(\n    channel: RealtimeChannel\n  ): Promise<RealtimeRemoveChannelResponse> {\n    const status = await channel.unsubscribe()\n\n    if (this.channels.length === 0) {\n      this.disconnect()\n    }\n\n    return status\n  }\n\n  /**\n   * Unsubscribes and removes all channels\n   */\n  async removeAllChannels(): Promise<RealtimeRemoveChannelResponse[]> {\n    const values_1 = await Promise.all(\n      this.channels.map((channel) => channel.unsubscribe())\n    )\n    this.channels = []\n    this.disconnect()\n    return values_1\n  }\n\n  /**\n   * Logs the message.\n   *\n   * For customized logging, `this.logger` can be overridden.\n   */\n  log(kind: string, msg: string, data?: any) {\n    this.logger(kind, msg, data)\n  }\n\n  /**\n   * Returns the current state of the socket.\n   */\n  connectionState(): CONNECTION_STATE {\n    switch (this.conn && this.conn.readyState) {\n      case SOCKET_STATES.connecting:\n        return CONNECTION_STATE.Connecting\n      case SOCKET_STATES.open:\n        return CONNECTION_STATE.Open\n      case SOCKET_STATES.closing:\n        return CONNECTION_STATE.Closing\n      default:\n        return CONNECTION_STATE.Closed\n    }\n  }\n\n  /**\n   * Returns `true` is the connection is open.\n   */\n  isConnected(): boolean {\n    return this.connectionState() === CONNECTION_STATE.Open\n  }\n\n  channel(\n    topic: string,\n    params: RealtimeChannelOptions = { config: {} }\n  ): RealtimeChannel {\n    const realtimeTopic = `realtime:${topic}`\n    const exists = this.getChannels().find(\n      (c: RealtimeChannel) => c.topic === realtimeTopic\n    )\n\n    if (!exists) {\n      const chan = new RealtimeChannel(`realtime:${topic}`, params, this)\n      this.channels.push(chan)\n\n      return chan\n    } else {\n      return exists\n    }\n  }\n\n  /**\n   * Push out a message if the socket is connected.\n   *\n   * If the socket is not connected, the message gets enqueued within a local buffer, and sent out when a connection is next established.\n   */\n  push(data: RealtimeMessage): void {\n    const { topic, event, payload, ref } = data\n    const callback = () => {\n      this.encode(data, (result: any) => {\n        this.conn?.send(result)\n      })\n    }\n    this.log('push', `${topic} ${event} (${ref})`, payload)\n    if (this.isConnected()) {\n      callback()\n    } else {\n      this.sendBuffer.push(callback)\n    }\n  }\n\n  /**\n   * Sets the JWT access token used for channel subscription authorization and Realtime RLS.\n   *\n   * If param is null it will use the `accessToken` callback function or the token set on the client.\n   *\n   * On callback used, it will set the value of the token internal to the client.\n   *\n   * @param token A JWT string to override the token set on the client.\n   */\n  async setAuth(token: string | null = null): Promise<void> {\n    let tokenToSend =\n      token ||\n      (this.accessToken && (await this.accessToken())) ||\n      this.accessTokenValue\n\n    if (this.accessTokenValue != tokenToSend) {\n      this.accessTokenValue = tokenToSend\n      this.channels.forEach((channel) => {\n        const payload = {\n          access_token: tokenToSend,\n          version: DEFAULT_VERSION,\n        }\n\n        tokenToSend && channel.updateJoinPayload(payload)\n\n        if (channel.joinedOnce && channel._isJoined()) {\n          channel._push(CHANNEL_EVENTS.access_token, {\n            access_token: tokenToSend,\n          })\n        }\n      })\n    }\n  }\n  /**\n   * Sends a heartbeat message if the socket is connected.\n   */\n  async sendHeartbeat() {\n    if (!this.isConnected()) {\n      this.heartbeatCallback('disconnected')\n      return\n    }\n    if (this.pendingHeartbeatRef) {\n      this.pendingHeartbeatRef = null\n      this.log(\n        'transport',\n        'heartbeat timeout. Attempting to re-establish connection'\n      )\n      this.heartbeatCallback('timeout')\n      this.conn?.close(WS_CLOSE_NORMAL, 'hearbeat timeout')\n      return\n    }\n    this.pendingHeartbeatRef = this._makeRef()\n    this.push({\n      topic: 'phoenix',\n      event: 'heartbeat',\n      payload: {},\n      ref: this.pendingHeartbeatRef,\n    })\n    this.heartbeatCallback('sent')\n    await this.setAuth()\n  }\n\n  onHeartbeat(callback: (status: HeartbeatStatus) => void): void {\n    this.heartbeatCallback = callback\n  }\n  /**\n   * Flushes send buffer\n   */\n  flushSendBuffer() {\n    if (this.isConnected() && this.sendBuffer.length > 0) {\n      this.sendBuffer.forEach((callback) => callback())\n      this.sendBuffer = []\n    }\n  }\n\n  /**\n   * Use either custom fetch, if provided, or default fetch to make HTTP requests\n   *\n   * @internal\n   */\n  _resolveFetch = (customFetch?: Fetch): Fetch => {\n    let _fetch: Fetch\n    if (customFetch) {\n      _fetch = customFetch\n    } else if (typeof fetch === 'undefined') {\n      _fetch = (...args) =>\n        import('@supabase/node-fetch' as any).then(({ default: fetch }) =>\n          fetch(...args)\n        )\n    } else {\n      _fetch = fetch\n    }\n    return (...args) => _fetch(...args)\n  }\n\n  /**\n   * Return the next message ref, accounting for overflows\n   *\n   * @internal\n   */\n  _makeRef(): string {\n    let newRef = this.ref + 1\n    if (newRef === this.ref) {\n      this.ref = 0\n    } else {\n      this.ref = newRef\n    }\n\n    return this.ref.toString()\n  }\n\n  /**\n   * Unsubscribe from channels with the specified topic.\n   *\n   * @internal\n   */\n  _leaveOpenTopic(topic: string): void {\n    let dupChannel = this.channels.find(\n      (c) => c.topic === topic && (c._isJoined() || c._isJoining())\n    )\n    if (dupChannel) {\n      this.log('transport', `leaving duplicate topic \"${topic}\"`)\n      dupChannel.unsubscribe()\n    }\n  }\n\n  /**\n   * Removes a subscription from the socket.\n   *\n   * @param channel An open subscription.\n   *\n   * @internal\n   */\n  _remove(channel: RealtimeChannel) {\n    this.channels = this.channels.filter((c) => c.topic !== channel.topic)\n  }\n\n  /**\n   * Sets up connection handlers.\n   *\n   * @internal\n   */\n  private setupConnection(): void {\n    if (this.conn) {\n      this.conn.binaryType = 'arraybuffer'\n      this.conn.onopen = () => this._onConnOpen()\n      this.conn.onerror = (error: Event) => this._onConnError(error)\n      this.conn.onmessage = (event: any) => this._onConnMessage(event)\n      this.conn.onclose = (event: any) => this._onConnClose(event)\n    }\n  }\n\n  /** @internal */\n  private _onConnMessage(rawMessage: { data: any }) {\n    this.decode(rawMessage.data, (msg: RealtimeMessage) => {\n      let { topic, event, payload, ref } = msg\n\n      if (topic === 'phoenix' && event === 'phx_reply') {\n        this.heartbeatCallback(msg.payload.status == 'ok' ? 'ok' : 'error')\n      }\n\n      if (ref && ref === this.pendingHeartbeatRef) {\n        this.pendingHeartbeatRef = null\n      }\n\n      this.log(\n        'receive',\n        `${payload.status || ''} ${topic} ${event} ${\n          (ref && '(' + ref + ')') || ''\n        }`,\n        payload\n      )\n\n      Array.from(this.channels)\n        .filter((channel: RealtimeChannel) => channel._isMember(topic))\n        .forEach((channel: RealtimeChannel) =>\n          channel._trigger(event, payload, ref)\n        )\n\n      this.stateChangeCallbacks.message.forEach((callback) => callback(msg))\n    })\n  }\n\n  /** @internal */\n  private _onConnOpen() {\n    this.log('transport', `connected to ${this.endpointURL()}`)\n    this.flushSendBuffer()\n    this.reconnectTimer.reset()\n    if (!this.worker) {\n      this._startHeartbeat()\n    } else {\n      if (!this.workerRef) {\n        this._startWorkerHeartbeat()\n      }\n    }\n\n    this.stateChangeCallbacks.open.forEach((callback) => callback())\n  }\n  /** @internal */\n  private _startHeartbeat() {\n    this.heartbeatTimer && clearInterval(this.heartbeatTimer)\n    this.heartbeatTimer = setInterval(\n      () => this.sendHeartbeat(),\n      this.heartbeatIntervalMs\n    )\n  }\n\n  /** @internal */\n  private _startWorkerHeartbeat() {\n    if (this.workerUrl) {\n      this.log('worker', `starting worker for from ${this.workerUrl}`)\n    } else {\n      this.log('worker', `starting default worker`)\n    }\n    const objectUrl = this._workerObjectUrl(this.workerUrl!)\n    this.workerRef = new Worker(objectUrl)\n    this.workerRef.onerror = (error) => {\n      this.log('worker', 'worker error', (error as ErrorEvent).message)\n      this.workerRef!.terminate()\n    }\n    this.workerRef.onmessage = (event) => {\n      if (event.data.event === 'keepAlive') {\n        this.sendHeartbeat()\n      }\n    }\n    this.workerRef.postMessage({\n      event: 'start',\n      interval: this.heartbeatIntervalMs,\n    })\n  }\n  /** @internal */\n  private _onConnClose(event: any) {\n    this.log('transport', 'close', event)\n    this._triggerChanError()\n    this.heartbeatTimer && clearInterval(this.heartbeatTimer)\n    this.reconnectTimer.scheduleTimeout()\n    this.stateChangeCallbacks.close.forEach((callback) => callback(event))\n  }\n\n  /** @internal */\n  private _onConnError(error: Event) {\n    this.log('transport', `${error}`)\n    this._triggerChanError()\n    this.stateChangeCallbacks.error.forEach((callback) => callback(error))\n  }\n\n  /** @internal */\n  private _triggerChanError() {\n    this.channels.forEach((channel: RealtimeChannel) =>\n      channel._trigger(CHANNEL_EVENTS.error)\n    )\n  }\n\n  /** @internal */\n  private _appendParams(\n    url: string,\n    params: { [key: string]: string }\n  ): string {\n    if (Object.keys(params).length === 0) {\n      return url\n    }\n    const prefix = url.match(/\\?/) ? '&' : '?'\n    const query = new URLSearchParams(params)\n    return `${url}${prefix}${query}`\n  }\n\n  private _workerObjectUrl(url: string | undefined): string {\n    let result_url: string\n    if (url) {\n      result_url = url\n    } else {\n      const blob = new Blob([WORKER_SCRIPT], { type: 'application/javascript' })\n      result_url = URL.createObjectURL(blob)\n    }\n    return result_url\n  }\n}\n", "export class StorageError extends Error {\n  protected __isStorageError = true\n\n  constructor(message: string) {\n    super(message)\n    this.name = 'StorageError'\n  }\n}\n\nexport function isStorageError(error: unknown): error is StorageError {\n  return typeof error === 'object' && error !== null && '__isStorageError' in error\n}\n\nexport class StorageApiError extends StorageError {\n  status: number\n  statusCode: string\n\n  constructor(message: string, status: number, statusCode: string) {\n    super(message)\n    this.name = 'StorageApiError'\n    this.status = status\n    this.statusCode = statusCode\n  }\n\n  toJSON() {\n    return {\n      name: this.name,\n      message: this.message,\n      status: this.status,\n      statusCode: this.statusCode,\n    }\n  }\n}\n\nexport class StorageUnknownError extends StorageError {\n  originalError: unknown\n\n  constructor(message: string, originalError: unknown) {\n    super(message)\n    this.name = 'StorageUnknownError'\n    this.originalError = originalError\n  }\n}\n", "type Fetch = typeof fetch\n\nexport const resolveFetch = (customFetch?: Fetch): Fetch => {\n  let _fetch: Fetch\n  if (customFetch) {\n    _fetch = customFetch\n  } else if (typeof fetch === 'undefined') {\n    _fetch = (...args) =>\n      import('@supabase/node-fetch' as any).then(({ default: fetch }) => fetch(...args))\n  } else {\n    _fetch = fetch\n  }\n  return (...args) => _fetch(...args)\n}\n\nexport const resolveResponse = async (): Promise<typeof Response> => {\n  if (typeof Response === 'undefined') {\n    // @ts-ignore\n    return (await import('@supabase/node-fetch' as any)).Response\n  }\n\n  return Response\n}\n\nexport const recursiveToCamel = (item: Record<string, any>): unknown => {\n  if (Array.isArray(item)) {\n    return item.map((el) => recursiveToCamel(el))\n  } else if (typeof item === 'function' || item !== Object(item)) {\n    return item\n  }\n\n  const result: Record<string, any> = {}\n  Object.entries(item).forEach(([key, value]) => {\n    const newKey = key.replace(/([-_][a-z])/gi, (c) => c.toUpperCase().replace(/[-_]/g, ''))\n    result[newKey] = recursiveToCamel(value)\n  })\n\n  return result\n}\n\n/**\n * Determine if input is a plain object\n * An object is plain if it's created by either {}, new Object(), or Object.create(null)\n * source: https://github.com/sindresorhus/is-plain-obj\n */\nexport const isPlainObject = (value: object): boolean => {\n  if (typeof value !== 'object' || value === null) {\n    return false\n  }\n\n  const prototype = Object.getPrototypeOf(value)\n  return (\n    (prototype === null ||\n      prototype === Object.prototype ||\n      Object.getPrototypeOf(prototype) === null) &&\n    !(Symbol.toStringTag in value) &&\n    !(Symbol.iterator in value)\n  )\n}\n", "import { StorageApiError, StorageUnknownError } from './errors'\nimport { isPlainObject, resolveResponse } from './helpers'\nimport { FetchParameters } from './types'\n\nexport type Fetch = typeof fetch\n\nexport interface FetchOptions {\n  headers?: {\n    [key: string]: string\n  }\n  noResolveJson?: boolean\n}\n\nexport type RequestMethodType = 'GET' | 'POST' | 'PUT' | 'DELETE' | 'HEAD'\n\nconst _getErrorMessage = (err: any): string =>\n  err.msg || err.message || err.error_description || err.error || JSON.stringify(err)\n\nconst handleError = async (\n  error: unknown,\n  reject: (reason?: any) => void,\n  options?: FetchOptions\n) => {\n  const Res = await resolveResponse()\n\n  if (error instanceof Res && !options?.noResolveJson) {\n    error\n      .json()\n      .then((err) => {\n        const status = error.status || 500\n        const statusCode = err?.statusCode || status + ''\n        reject(new StorageApiError(_getErrorMessage(err), status, statusCode))\n      })\n      .catch((err) => {\n        reject(new StorageUnknownError(_getErrorMessage(err), err))\n      })\n  } else {\n    reject(new StorageUnknownError(_getErrorMessage(error), error))\n  }\n}\n\nconst _getRequestParams = (\n  method: RequestMethodType,\n  options?: FetchOptions,\n  parameters?: FetchParameters,\n  body?: object\n) => {\n  const params: { [k: string]: any } = { method, headers: options?.headers || {} }\n\n  if (method === 'GET' || !body) {\n    return params\n  }\n\n  if (isPlainObject(body)) {\n    params.headers = { 'Content-Type': 'application/json', ...options?.headers }\n    params.body = JSON.stringify(body)\n  } else {\n    params.body = body\n  }\n\n  return { ...params, ...parameters }\n}\n\nasync function _handleRequest(\n  fetcher: Fetch,\n  method: RequestMethodType,\n  url: string,\n  options?: FetchOptions,\n  parameters?: FetchParameters,\n  body?: object\n): Promise<any> {\n  return new Promise((resolve, reject) => {\n    fetcher(url, _getRequestParams(method, options, parameters, body))\n      .then((result) => {\n        if (!result.ok) throw result\n        if (options?.noResolveJson) return result\n        return result.json()\n      })\n      .then((data) => resolve(data))\n      .catch((error) => handleError(error, reject, options))\n  })\n}\n\nexport async function get(\n  fetcher: Fetch,\n  url: string,\n  options?: FetchOptions,\n  parameters?: FetchParameters\n): Promise<any> {\n  return _handleRequest(fetcher, 'GET', url, options, parameters)\n}\n\nexport async function post(\n  fetcher: Fetch,\n  url: string,\n  body: object,\n  options?: FetchOptions,\n  parameters?: FetchParameters\n): Promise<any> {\n  return _handleRequest(fetcher, 'POST', url, options, parameters, body)\n}\n\nexport async function put(\n  fetcher: Fetch,\n  url: string,\n  body: object,\n  options?: FetchOptions,\n  parameters?: FetchParameters\n): Promise<any> {\n  return _handleRequest(fetcher, 'PUT', url, options, parameters, body)\n}\n\nexport async function head(\n  fetcher: Fetch,\n  url: string,\n  options?: FetchOptions,\n  parameters?: FetchParameters\n): Promise<any> {\n  return _handleRequest(\n    fetcher,\n    'HEAD',\n    url,\n    {\n      ...options,\n      noResolveJson: true,\n    },\n    parameters\n  )\n}\n\nexport async function remove(\n  fetcher: Fetch,\n  url: string,\n  body: object,\n  options?: FetchOptions,\n  parameters?: FetchParameters\n): Promise<any> {\n  return _handleRequest(fetcher, 'DELETE', url, options, parameters, body)\n}\n", "import { isStorageError, StorageError, StorageUnknownError } from '../lib/errors'\nimport { Fetch, get, head, post, put, remove } from '../lib/fetch'\nimport { recursiveToCamel, resolveFetch } from '../lib/helpers'\nimport {\n  FileObject,\n  FileOptions,\n  SearchOptions,\n  FetchParameters,\n  TransformOptions,\n  DestinationOptions,\n  FileObjectV2,\n  Camelize,\n} from '../lib/types'\n\nconst DEFAULT_SEARCH_OPTIONS = {\n  limit: 100,\n  offset: 0,\n  sortBy: {\n    column: 'name',\n    order: 'asc',\n  },\n}\n\nconst DEFAULT_FILE_OPTIONS: FileOptions = {\n  cacheControl: '3600',\n  contentType: 'text/plain;charset=UTF-8',\n  upsert: false,\n}\n\ntype FileBody =\n  | ArrayBuffer\n  | ArrayBufferView\n  | Blob\n  | Buffer\n  | File\n  | FormData\n  | NodeJS.ReadableStream\n  | ReadableStream<Uint8Array>\n  | URLSearchParams\n  | string\n\nexport default class StorageFileApi {\n  protected url: string\n  protected headers: { [key: string]: string }\n  protected bucketId?: string\n  protected fetch: Fetch\n\n  constructor(\n    url: string,\n    headers: { [key: string]: string } = {},\n    bucketId?: string,\n    fetch?: Fetch\n  ) {\n    this.url = url\n    this.headers = headers\n    this.bucketId = bucketId\n    this.fetch = resolveFetch(fetch)\n  }\n\n  /**\n   * Uploads a file to an existing bucket or replaces an existing file at the specified path with a new one.\n   *\n   * @param method HTTP method.\n   * @param path The relative file path. Should be of the format `folder/subfolder/filename.png`. The bucket must already exist before attempting to upload.\n   * @param fileBody The body of the file to be stored in the bucket.\n   */\n  private async uploadOrUpdate(\n    method: 'POST' | 'PUT',\n    path: string,\n    fileBody: FileBody,\n    fileOptions?: FileOptions\n  ): Promise<\n    | {\n        data: { id: string; path: string; fullPath: string }\n        error: null\n      }\n    | {\n        data: null\n        error: StorageError\n      }\n  > {\n    try {\n      let body\n      const options = { ...DEFAULT_FILE_OPTIONS, ...fileOptions }\n      let headers: Record<string, string> = {\n        ...this.headers,\n        ...(method === 'POST' && { 'x-upsert': String(options.upsert as boolean) }),\n      }\n\n      const metadata = options.metadata\n\n      if (typeof Blob !== 'undefined' && fileBody instanceof Blob) {\n        body = new FormData()\n        body.append('cacheControl', options.cacheControl as string)\n        if (metadata) {\n          body.append('metadata', this.encodeMetadata(metadata))\n        }\n        body.append('', fileBody)\n      } else if (typeof FormData !== 'undefined' && fileBody instanceof FormData) {\n        body = fileBody\n        body.append('cacheControl', options.cacheControl as string)\n        if (metadata) {\n          body.append('metadata', this.encodeMetadata(metadata))\n        }\n      } else {\n        body = fileBody\n        headers['cache-control'] = `max-age=${options.cacheControl}`\n        headers['content-type'] = options.contentType as string\n\n        if (metadata) {\n          headers['x-metadata'] = this.toBase64(this.encodeMetadata(metadata))\n        }\n      }\n\n      if (fileOptions?.headers) {\n        headers = { ...headers, ...fileOptions.headers }\n      }\n\n      const cleanPath = this._removeEmptyFolders(path)\n      const _path = this._getFinalPath(cleanPath)\n      const data = await (method == 'PUT' ? put : post)(\n        this.fetch,\n        `${this.url}/object/${_path}`,\n        body as object,\n        { headers, ...(options?.duplex ? { duplex: options.duplex } : {}) }\n      )\n\n      return {\n        data: { path: cleanPath, id: data.Id, fullPath: data.Key },\n        error: null,\n      }\n    } catch (error) {\n      if (isStorageError(error)) {\n        return { data: null, error }\n      }\n\n      throw error\n    }\n  }\n\n  /**\n   * Uploads a file to an existing bucket.\n   *\n   * @param path The file path, including the file name. Should be of the format `folder/subfolder/filename.png`. The bucket must already exist before attempting to upload.\n   * @param fileBody The body of the file to be stored in the bucket.\n   */\n  async upload(\n    path: string,\n    fileBody: FileBody,\n    fileOptions?: FileOptions\n  ): Promise<\n    | {\n        data: { id: string; path: string; fullPath: string }\n        error: null\n      }\n    | {\n        data: null\n        error: StorageError\n      }\n  > {\n    return this.uploadOrUpdate('POST', path, fileBody, fileOptions)\n  }\n\n  /**\n   * Upload a file with a token generated from `createSignedUploadUrl`.\n   * @param path The file path, including the file name. Should be of the format `folder/subfolder/filename.png`. The bucket must already exist before attempting to upload.\n   * @param token The token generated from `createSignedUploadUrl`\n   * @param fileBody The body of the file to be stored in the bucket.\n   */\n  async uploadToSignedUrl(\n    path: string,\n    token: string,\n    fileBody: FileBody,\n    fileOptions?: FileOptions\n  ) {\n    const cleanPath = this._removeEmptyFolders(path)\n    const _path = this._getFinalPath(cleanPath)\n\n    const url = new URL(this.url + `/object/upload/sign/${_path}`)\n    url.searchParams.set('token', token)\n\n    try {\n      let body\n      const options = { upsert: DEFAULT_FILE_OPTIONS.upsert, ...fileOptions }\n      const headers: Record<string, string> = {\n        ...this.headers,\n        ...{ 'x-upsert': String(options.upsert as boolean) },\n      }\n\n      if (typeof Blob !== 'undefined' && fileBody instanceof Blob) {\n        body = new FormData()\n        body.append('cacheControl', options.cacheControl as string)\n        body.append('', fileBody)\n      } else if (typeof FormData !== 'undefined' && fileBody instanceof FormData) {\n        body = fileBody\n        body.append('cacheControl', options.cacheControl as string)\n      } else {\n        body = fileBody\n        headers['cache-control'] = `max-age=${options.cacheControl}`\n        headers['content-type'] = options.contentType as string\n      }\n\n      const data = await put(this.fetch, url.toString(), body as object, { headers })\n\n      return {\n        data: { path: cleanPath, fullPath: data.Key },\n        error: null,\n      }\n    } catch (error) {\n      if (isStorageError(error)) {\n        return { data: null, error }\n      }\n\n      throw error\n    }\n  }\n\n  /**\n   * Creates a signed upload URL.\n   * Signed upload URLs can be used to upload files to the bucket without further authentication.\n   * They are valid for 2 hours.\n   * @param path The file path, including the current file name. For example `folder/image.png`.\n   * @param options.upsert If set to true, allows the file to be overwritten if it already exists.\n   */\n  async createSignedUploadUrl(\n    path: string,\n    options?: { upsert: boolean }\n  ): Promise<\n    | {\n        data: { signedUrl: string; token: string; path: string }\n        error: null\n      }\n    | {\n        data: null\n        error: StorageError\n      }\n  > {\n    try {\n      let _path = this._getFinalPath(path)\n\n      const headers = { ...this.headers }\n\n      if (options?.upsert) {\n        headers['x-upsert'] = 'true'\n      }\n\n      const data = await post(\n        this.fetch,\n        `${this.url}/object/upload/sign/${_path}`,\n        {},\n        { headers }\n      )\n\n      const url = new URL(this.url + data.url)\n\n      const token = url.searchParams.get('token')\n\n      if (!token) {\n        throw new StorageError('No token returned by API')\n      }\n\n      return { data: { signedUrl: url.toString(), path, token }, error: null }\n    } catch (error) {\n      if (isStorageError(error)) {\n        return { data: null, error }\n      }\n\n      throw error\n    }\n  }\n\n  /**\n   * Replaces an existing file at the specified path with a new one.\n   *\n   * @param path The relative file path. Should be of the format `folder/subfolder/filename.png`. The bucket must already exist before attempting to update.\n   * @param fileBody The body of the file to be stored in the bucket.\n   */\n  async update(\n    path: string,\n    fileBody:\n      | ArrayBuffer\n      | ArrayBufferView\n      | Blob\n      | Buffer\n      | File\n      | FormData\n      | NodeJS.ReadableStream\n      | ReadableStream<Uint8Array>\n      | URLSearchParams\n      | string,\n    fileOptions?: FileOptions\n  ): Promise<\n    | {\n        data: { id: string; path: string; fullPath: string }\n        error: null\n      }\n    | {\n        data: null\n        error: StorageError\n      }\n  > {\n    return this.uploadOrUpdate('PUT', path, fileBody, fileOptions)\n  }\n\n  /**\n   * Moves an existing file to a new path in the same bucket.\n   *\n   * @param fromPath The original file path, including the current file name. For example `folder/image.png`.\n   * @param toPath The new file path, including the new file name. For example `folder/image-new.png`.\n   * @param options The destination options.\n   */\n  async move(\n    fromPath: string,\n    toPath: string,\n    options?: DestinationOptions\n  ): Promise<\n    | {\n        data: { message: string }\n        error: null\n      }\n    | {\n        data: null\n        error: StorageError\n      }\n  > {\n    try {\n      const data = await post(\n        this.fetch,\n        `${this.url}/object/move`,\n        {\n          bucketId: this.bucketId,\n          sourceKey: fromPath,\n          destinationKey: toPath,\n          destinationBucket: options?.destinationBucket,\n        },\n        { headers: this.headers }\n      )\n      return { data, error: null }\n    } catch (error) {\n      if (isStorageError(error)) {\n        return { data: null, error }\n      }\n\n      throw error\n    }\n  }\n\n  /**\n   * Copies an existing file to a new path in the same bucket.\n   *\n   * @param fromPath The original file path, including the current file name. For example `folder/image.png`.\n   * @param toPath The new file path, including the new file name. For example `folder/image-copy.png`.\n   * @param options The destination options.\n   */\n  async copy(\n    fromPath: string,\n    toPath: string,\n    options?: DestinationOptions\n  ): Promise<\n    | {\n        data: { path: string }\n        error: null\n      }\n    | {\n        data: null\n        error: StorageError\n      }\n  > {\n    try {\n      const data = await post(\n        this.fetch,\n        `${this.url}/object/copy`,\n        {\n          bucketId: this.bucketId,\n          sourceKey: fromPath,\n          destinationKey: toPath,\n          destinationBucket: options?.destinationBucket,\n        },\n        { headers: this.headers }\n      )\n      return { data: { path: data.Key }, error: null }\n    } catch (error) {\n      if (isStorageError(error)) {\n        return { data: null, error }\n      }\n\n      throw error\n    }\n  }\n\n  /**\n   * Creates a signed URL. Use a signed URL to share a file for a fixed amount of time.\n   *\n   * @param path The file path, including the current file name. For example `folder/image.png`.\n   * @param expiresIn The number of seconds until the signed URL expires. For example, `60` for a URL which is valid for one minute.\n   * @param options.download triggers the file as a download if set to true. Set this parameter as the name of the file if you want to trigger the download with a different filename.\n   * @param options.transform Transform the asset before serving it to the client.\n   */\n  async createSignedUrl(\n    path: string,\n    expiresIn: number,\n    options?: { download?: string | boolean; transform?: TransformOptions }\n  ): Promise<\n    | {\n        data: { signedUrl: string }\n        error: null\n      }\n    | {\n        data: null\n        error: StorageError\n      }\n  > {\n    try {\n      let _path = this._getFinalPath(path)\n\n      let data = await post(\n        this.fetch,\n        `${this.url}/object/sign/${_path}`,\n        { expiresIn, ...(options?.transform ? { transform: options.transform } : {}) },\n        { headers: this.headers }\n      )\n      const downloadQueryParam = options?.download\n        ? `&download=${options.download === true ? '' : options.download}`\n        : ''\n      const signedUrl = encodeURI(`${this.url}${data.signedURL}${downloadQueryParam}`)\n      data = { signedUrl }\n      return { data, error: null }\n    } catch (error) {\n      if (isStorageError(error)) {\n        return { data: null, error }\n      }\n\n      throw error\n    }\n  }\n\n  /**\n   * Creates multiple signed URLs. Use a signed URL to share a file for a fixed amount of time.\n   *\n   * @param paths The file paths to be downloaded, including the current file names. For example `['folder/image.png', 'folder2/image2.png']`.\n   * @param expiresIn The number of seconds until the signed URLs expire. For example, `60` for URLs which are valid for one minute.\n   * @param options.download triggers the file as a download if set to true. Set this parameter as the name of the file if you want to trigger the download with a different filename.\n   */\n  async createSignedUrls(\n    paths: string[],\n    expiresIn: number,\n    options?: { download: string | boolean }\n  ): Promise<\n    | {\n        data: { error: string | null; path: string | null; signedUrl: string }[]\n        error: null\n      }\n    | {\n        data: null\n        error: StorageError\n      }\n  > {\n    try {\n      const data = await post(\n        this.fetch,\n        `${this.url}/object/sign/${this.bucketId}`,\n        { expiresIn, paths },\n        { headers: this.headers }\n      )\n\n      const downloadQueryParam = options?.download\n        ? `&download=${options.download === true ? '' : options.download}`\n        : ''\n      return {\n        data: data.map((datum: { signedURL: string }) => ({\n          ...datum,\n          signedUrl: datum.signedURL\n            ? encodeURI(`${this.url}${datum.signedURL}${downloadQueryParam}`)\n            : null,\n        })),\n        error: null,\n      }\n    } catch (error) {\n      if (isStorageError(error)) {\n        return { data: null, error }\n      }\n\n      throw error\n    }\n  }\n\n  /**\n   * Downloads a file from a private bucket. For public buckets, make a request to the URL returned from `getPublicUrl` instead.\n   *\n   * @param path The full path and file name of the file to be downloaded. For example `folder/image.png`.\n   * @param options.transform Transform the asset before serving it to the client.\n   */\n  async download(\n    path: string,\n    options?: { transform?: TransformOptions }\n  ): Promise<\n    | {\n        data: Blob\n        error: null\n      }\n    | {\n        data: null\n        error: StorageError\n      }\n  > {\n    const wantsTransformation = typeof options?.transform !== 'undefined'\n    const renderPath = wantsTransformation ? 'render/image/authenticated' : 'object'\n    const transformationQuery = this.transformOptsToQueryString(options?.transform || {})\n    const queryString = transformationQuery ? `?${transformationQuery}` : ''\n\n    try {\n      const _path = this._getFinalPath(path)\n      const res = await get(this.fetch, `${this.url}/${renderPath}/${_path}${queryString}`, {\n        headers: this.headers,\n        noResolveJson: true,\n      })\n      const data = await res.blob()\n      return { data, error: null }\n    } catch (error) {\n      if (isStorageError(error)) {\n        return { data: null, error }\n      }\n\n      throw error\n    }\n  }\n\n  /**\n   * Retrieves the details of an existing file.\n   * @param path\n   */\n  async info(\n    path: string\n  ): Promise<\n    | {\n        data: Camelize<FileObjectV2>\n        error: null\n      }\n    | {\n        data: null\n        error: StorageError\n      }\n  > {\n    const _path = this._getFinalPath(path)\n\n    try {\n      const data = await get(this.fetch, `${this.url}/object/info/${_path}`, {\n        headers: this.headers,\n      })\n\n      return { data: recursiveToCamel(data) as Camelize<FileObjectV2>, error: null }\n    } catch (error) {\n      if (isStorageError(error)) {\n        return { data: null, error }\n      }\n\n      throw error\n    }\n  }\n\n  /**\n   * Checks the existence of a file.\n   * @param path\n   */\n  async exists(\n    path: string\n  ): Promise<\n    | {\n        data: boolean\n        error: null\n      }\n    | {\n        data: boolean\n        error: StorageError\n      }\n  > {\n    const _path = this._getFinalPath(path)\n\n    try {\n      await head(this.fetch, `${this.url}/object/${_path}`, {\n        headers: this.headers,\n      })\n\n      return { data: true, error: null }\n    } catch (error) {\n      if (isStorageError(error) && error instanceof StorageUnknownError) {\n        const originalError = (error.originalError as unknown) as { status: number }\n\n        if ([400, 404].includes(originalError?.status)) {\n          return { data: false, error }\n        }\n      }\n\n      throw error\n    }\n  }\n\n  /**\n   * A simple convenience function to get the URL for an asset in a public bucket. If you do not want to use this function, you can construct the public URL by concatenating the bucket URL with the path to the asset.\n   * This function does not verify if the bucket is public. If a public URL is created for a bucket which is not public, you will not be able to download the asset.\n   *\n   * @param path The path and name of the file to generate the public URL for. For example `folder/image.png`.\n   * @param options.download Triggers the file as a download if set to true. Set this parameter as the name of the file if you want to trigger the download with a different filename.\n   * @param options.transform Transform the asset before serving it to the client.\n   */\n  getPublicUrl(\n    path: string,\n    options?: { download?: string | boolean; transform?: TransformOptions }\n  ): { data: { publicUrl: string } } {\n    const _path = this._getFinalPath(path)\n    const _queryString = []\n\n    const downloadQueryParam = options?.download\n      ? `download=${options.download === true ? '' : options.download}`\n      : ''\n\n    if (downloadQueryParam !== '') {\n      _queryString.push(downloadQueryParam)\n    }\n\n    const wantsTransformation = typeof options?.transform !== 'undefined'\n    const renderPath = wantsTransformation ? 'render/image' : 'object'\n    const transformationQuery = this.transformOptsToQueryString(options?.transform || {})\n\n    if (transformationQuery !== '') {\n      _queryString.push(transformationQuery)\n    }\n\n    let queryString = _queryString.join('&')\n    if (queryString !== '') {\n      queryString = `?${queryString}`\n    }\n\n    return {\n      data: { publicUrl: encodeURI(`${this.url}/${renderPath}/public/${_path}${queryString}`) },\n    }\n  }\n\n  /**\n   * Deletes files within the same bucket\n   *\n   * @param paths An array of files to delete, including the path and file name. For example [`'folder/image.png'`].\n   */\n  async remove(\n    paths: string[]\n  ): Promise<\n    | {\n        data: FileObject[]\n        error: null\n      }\n    | {\n        data: null\n        error: StorageError\n      }\n  > {\n    try {\n      const data = await remove(\n        this.fetch,\n        `${this.url}/object/${this.bucketId}`,\n        { prefixes: paths },\n        { headers: this.headers }\n      )\n      return { data, error: null }\n    } catch (error) {\n      if (isStorageError(error)) {\n        return { data: null, error }\n      }\n\n      throw error\n    }\n  }\n\n  /**\n   * Get file metadata\n   * @param id the file id to retrieve metadata\n   */\n  // async getMetadata(\n  //   id: string\n  // ): Promise<\n  //   | {\n  //       data: Metadata\n  //       error: null\n  //     }\n  //   | {\n  //       data: null\n  //       error: StorageError\n  //     }\n  // > {\n  //   try {\n  //     const data = await get(this.fetch, `${this.url}/metadata/${id}`, { headers: this.headers })\n  //     return { data, error: null }\n  //   } catch (error) {\n  //     if (isStorageError(error)) {\n  //       return { data: null, error }\n  //     }\n\n  //     throw error\n  //   }\n  // }\n\n  /**\n   * Update file metadata\n   * @param id the file id to update metadata\n   * @param meta the new file metadata\n   */\n  // async updateMetadata(\n  //   id: string,\n  //   meta: Metadata\n  // ): Promise<\n  //   | {\n  //       data: Metadata\n  //       error: null\n  //     }\n  //   | {\n  //       data: null\n  //       error: StorageError\n  //     }\n  // > {\n  //   try {\n  //     const data = await post(\n  //       this.fetch,\n  //       `${this.url}/metadata/${id}`,\n  //       { ...meta },\n  //       { headers: this.headers }\n  //     )\n  //     return { data, error: null }\n  //   } catch (error) {\n  //     if (isStorageError(error)) {\n  //       return { data: null, error }\n  //     }\n\n  //     throw error\n  //   }\n  // }\n\n  /**\n   * Lists all the files within a bucket.\n   * @param path The folder path.\n   */\n  async list(\n    path?: string,\n    options?: SearchOptions,\n    parameters?: FetchParameters\n  ): Promise<\n    | {\n        data: FileObject[]\n        error: null\n      }\n    | {\n        data: null\n        error: StorageError\n      }\n  > {\n    try {\n      const body = { ...DEFAULT_SEARCH_OPTIONS, ...options, prefix: path || '' }\n      const data = await post(\n        this.fetch,\n        `${this.url}/object/list/${this.bucketId}`,\n        body,\n        { headers: this.headers },\n        parameters\n      )\n      return { data, error: null }\n    } catch (error) {\n      if (isStorageError(error)) {\n        return { data: null, error }\n      }\n\n      throw error\n    }\n  }\n\n  protected encodeMetadata(metadata: Record<string, any>) {\n    return JSON.stringify(metadata)\n  }\n\n  toBase64(data: string) {\n    if (typeof Buffer !== 'undefined') {\n      return Buffer.from(data).toString('base64')\n    }\n    return btoa(data)\n  }\n\n  private _getFinalPath(path: string) {\n    return `${this.bucketId}/${path}`\n  }\n\n  private _removeEmptyFolders(path: string) {\n    return path.replace(/^\\/|\\/$/g, '').replace(/\\/+/g, '/')\n  }\n\n  private transformOptsToQueryString(transform: TransformOptions) {\n    const params = []\n    if (transform.width) {\n      params.push(`width=${transform.width}`)\n    }\n\n    if (transform.height) {\n      params.push(`height=${transform.height}`)\n    }\n\n    if (transform.resize) {\n      params.push(`resize=${transform.resize}`)\n    }\n\n    if (transform.format) {\n      params.push(`format=${transform.format}`)\n    }\n\n    if (transform.quality) {\n      params.push(`quality=${transform.quality}`)\n    }\n\n    return params.join('&')\n  }\n}\n", "// generated by genversion\nexport const version = '2.10.2'\n", "import { version } from './version'\nexport const DEFAULT_HEADERS = { 'X-Client-Info': `storage-js/${version}` }\n", "import { DEFAULT_HEADERS } from '../lib/constants'\nimport { isStorageError, StorageError } from '../lib/errors'\nimport { Fetch, get, post, put, remove } from '../lib/fetch'\nimport { resolveFetch } from '../lib/helpers'\nimport { Bucket, BucketType } from '../lib/types'\n\nexport default class StorageBucketApi {\n  protected url: string\n  protected headers: { [key: string]: string }\n  protected fetch: Fetch\n\n  constructor(\n    url: string,\n    headers: { [key: string]: string } = {},\n    fetch?: Fetch,\n    opts?: { useNewHostname?: boolean }\n  ) {\n    const baseUrl = new URL(url)\n\n    // if legacy uri is used, replace with new storage host (disables request buffering to allow > 50GB uploads)\n    // \"project-ref.supabase.co/storage/v1\" becomes \"project-ref.storage.supabase.co/v1\"\n    if (opts?.useNewHostname) {\n      const isSupabaseHost = /supabase\\.(co|in|red)$/.test(baseUrl.hostname)\n      const legacyStoragePrefix = '/storage'\n      if (\n        isSupabaseHost &&\n        !baseUrl.hostname.includes('storage.supabase.') &&\n        baseUrl.pathname.startsWith(legacyStoragePrefix)\n      ) {\n        baseUrl.pathname = baseUrl.pathname.substring(legacyStoragePrefix.length)\n        baseUrl.hostname = baseUrl.hostname.replace('supabase.', 'storage.supabase.')\n      }\n    }\n\n    this.url = baseUrl.href\n    this.headers = { ...DEFAULT_HEADERS, ...headers }\n    this.fetch = resolveFetch(fetch)\n  }\n\n  /**\n   * Retrieves the details of all Storage buckets within an existing project.\n   */\n  async listBuckets(): Promise<\n    | {\n        data: Bucket[]\n        error: null\n      }\n    | {\n        data: null\n        error: StorageError\n      }\n  > {\n    try {\n      const data = await get(this.fetch, `${this.url}/bucket`, { headers: this.headers })\n      return { data, error: null }\n    } catch (error) {\n      if (isStorageError(error)) {\n        return { data: null, error }\n      }\n\n      throw error\n    }\n  }\n\n  /**\n   * Retrieves the details of an existing Storage bucket.\n   *\n   * @param id The unique identifier of the bucket you would like to retrieve.\n   */\n  async getBucket(\n    id: string\n  ): Promise<\n    | {\n        data: Bucket\n        error: null\n      }\n    | {\n        data: null\n        error: StorageError\n      }\n  > {\n    try {\n      const data = await get(this.fetch, `${this.url}/bucket/${id}`, { headers: this.headers })\n      return { data, error: null }\n    } catch (error) {\n      if (isStorageError(error)) {\n        return { data: null, error }\n      }\n\n      throw error\n    }\n  }\n\n  /**\n   * Creates a new Storage bucket\n   *\n   * @param id A unique identifier for the bucket you are creating.\n   * @param options.public The visibility of the bucket. Public buckets don't require an authorization token to download objects, but still require a valid token for all other operations. By default, buckets are private.\n   * @param options.fileSizeLimit specifies the max file size in bytes that can be uploaded to this bucket.\n   * The global file size limit takes precedence over this value.\n   * The default value is null, which doesn't set a per bucket file size limit.\n   * @param options.allowedMimeTypes specifies the allowed mime types that this bucket can accept during upload.\n   * The default value is null, which allows files with all mime types to be uploaded.\n   * Each mime type specified can be a wildcard, e.g. image/*, or a specific mime type, e.g. image/png.\n   * @returns newly created bucket id\n   * @param options.type (private-beta) specifies the bucket type. see `BucketType` for more details.\n   *   - default bucket type is `STANDARD`\n   */\n  async createBucket(\n    id: string,\n    options: {\n      public: boolean\n      fileSizeLimit?: number | string | null\n      allowedMimeTypes?: string[] | null\n      type?: BucketType\n    } = {\n      public: false,\n    }\n  ): Promise<\n    | {\n        data: Pick<Bucket, 'name'>\n        error: null\n      }\n    | {\n        data: null\n        error: StorageError\n      }\n  > {\n    try {\n      const data = await post(\n        this.fetch,\n        `${this.url}/bucket`,\n        {\n          id,\n          name: id,\n          type: options.type,\n          public: options.public,\n          file_size_limit: options.fileSizeLimit,\n          allowed_mime_types: options.allowedMimeTypes,\n        },\n        { headers: this.headers }\n      )\n      return { data, error: null }\n    } catch (error) {\n      if (isStorageError(error)) {\n        return { data: null, error }\n      }\n\n      throw error\n    }\n  }\n\n  /**\n   * Updates a Storage bucket\n   *\n   * @param id A unique identifier for the bucket you are updating.\n   * @param options.public The visibility of the bucket. Public buckets don't require an authorization token to download objects, but still require a valid token for all other operations.\n   * @param options.fileSizeLimit specifies the max file size in bytes that can be uploaded to this bucket.\n   * The global file size limit takes precedence over this value.\n   * The default value is null, which doesn't set a per bucket file size limit.\n   * @param options.allowedMimeTypes specifies the allowed mime types that this bucket can accept during upload.\n   * The default value is null, which allows files with all mime types to be uploaded.\n   * Each mime type specified can be a wildcard, e.g. image/*, or a specific mime type, e.g. image/png.\n   */\n  async updateBucket(\n    id: string,\n    options: {\n      public: boolean\n      fileSizeLimit?: number | string | null\n      allowedMimeTypes?: string[] | null\n    }\n  ): Promise<\n    | {\n        data: { message: string }\n        error: null\n      }\n    | {\n        data: null\n        error: StorageError\n      }\n  > {\n    try {\n      const data = await put(\n        this.fetch,\n        `${this.url}/bucket/${id}`,\n        {\n          id,\n          name: id,\n          public: options.public,\n          file_size_limit: options.fileSizeLimit,\n          allowed_mime_types: options.allowedMimeTypes,\n        },\n        { headers: this.headers }\n      )\n      return { data, error: null }\n    } catch (error) {\n      if (isStorageError(error)) {\n        return { data: null, error }\n      }\n\n      throw error\n    }\n  }\n\n  /**\n   * Removes all objects inside a single bucket.\n   *\n   * @param id The unique identifier of the bucket you would like to empty.\n   */\n  async emptyBucket(\n    id: string\n  ): Promise<\n    | {\n        data: { message: string }\n        error: null\n      }\n    | {\n        data: null\n        error: StorageError\n      }\n  > {\n    try {\n      const data = await post(\n        this.fetch,\n        `${this.url}/bucket/${id}/empty`,\n        {},\n        { headers: this.headers }\n      )\n      return { data, error: null }\n    } catch (error) {\n      if (isStorageError(error)) {\n        return { data: null, error }\n      }\n\n      throw error\n    }\n  }\n\n  /**\n   * Deletes an existing bucket. A bucket can't be deleted with existing objects inside it.\n   * You must first `empty()` the bucket.\n   *\n   * @param id The unique identifier of the bucket you would like to delete.\n   */\n  async deleteBucket(\n    id: string\n  ): Promise<\n    | {\n        data: { message: string }\n        error: null\n      }\n    | {\n        data: null\n        error: StorageError\n      }\n  > {\n    try {\n      const data = await remove(\n        this.fetch,\n        `${this.url}/bucket/${id}`,\n        {},\n        { headers: this.headers }\n      )\n      return { data, error: null }\n    } catch (error) {\n      if (isStorageError(error)) {\n        return { data: null, error }\n      }\n\n      throw error\n    }\n  }\n}\n", "import StorageFileApi from './packages/StorageFileApi'\nimport StorageBucketApi from './packages/StorageBucketApi'\nimport { Fetch } from './lib/fetch'\n\nexport class StorageClient extends StorageBucketApi {\n  constructor(\n    url: string,\n    headers: { [key: string]: string } = {},\n    fetch?: Fetch,\n    opts?: { useNewHostname?: boolean }\n  ) {\n    super(url, headers, fetch, opts)\n  }\n\n  /**\n   * Perform file operation in a bucket.\n   *\n   * @param id The bucket id to operate on.\n   */\n  from(id: string): StorageFileApi {\n    return new StorageFileApi(this.url, this.headers, id, this.fetch)\n  }\n}\n", "export const version = '2.30.0'\n", "// constants.ts\nimport { version } from './version'\nexport const DEFAULT_HEADERS = { 'X-Client-Info': `supabase-js/${version}` }\n", "import crossFetch, { Headers as CrossFetchHeaders } from 'cross-fetch'\n\ntype Fetch = typeof fetch\n\nexport const resolveFetch = (customFetch?: Fetch): Fetch => {\n  let _fetch: Fetch\n  if (customFetch) {\n    _fetch = customFetch\n  } else if (typeof fetch === 'undefined') {\n    _fetch = crossFetch as unknown as Fetch\n  } else {\n    _fetch = fetch\n  }\n  return (...args) => _fetch(...args)\n}\n\nexport const resolveHeadersConstructor = () => {\n  if (typeof Headers === 'undefined') {\n    return CrossFetchHeaders\n  }\n\n  return Headers\n}\n\nexport const fetchWithAuth = (\n  supabaseKey: string,\n  getAccessToken: () => Promise<string | null>,\n  customFetch?: Fetch\n): Fetch => {\n  const fetch = resolveFetch(customFetch)\n  const HeadersConstructor = resolveHeadersConstructor()\n\n  return async (input, init) => {\n    const accessToken = (await getAccessToken()) ?? supabaseKey\n    let headers = new HeadersConstructor(init?.headers)\n\n    if (!headers.has('apikey')) {\n      headers.set('apikey', supabaseKey)\n    }\n\n    if (!headers.has('Authorization')) {\n      headers.set('Authorization', `Bearer ${accessToken}`)\n    }\n\n    return fetch(input, { ...init, headers })\n  }\n}\n", "// helpers.ts\nimport { SupabaseClientOptions } from './types'\n\nexport function uuid() {\n  return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function (c) {\n    var r = (Math.random() * 16) | 0,\n      v = c == 'x' ? r : (r & 0x3) | 0x8\n    return v.toString(16)\n  })\n}\n\nexport function stripTrailingSlash(url: string): string {\n  return url.replace(/\\/$/, '')\n}\n\nexport const isBrowser = () => typeof window !== 'undefined'\n\nexport function applySettingDefaults<\n  Database = any,\n  SchemaName extends string & keyof Database = 'public' extends keyof Database\n    ? 'public'\n    : string & keyof Database\n>(\n  options: SupabaseClientOptions<SchemaName>,\n  defaults: SupabaseClientOptions<any>\n): SupabaseClientOptions<SchemaName> {\n  const {\n    db: dbOptions,\n    auth: authOptions,\n    realtime: realtimeOptions,\n    global: globalOptions,\n  } = options\n  const {\n    db: DEFAULT_DB_OPTIONS,\n    auth: DEFAULT_AUTH_OPTIONS,\n    realtime: DEFAULT_REALTIME_OPTIONS,\n    global: DEFAULT_GLOBAL_OPTIONS,\n  } = defaults\n\n  return {\n    db: {\n      ...DEFAULT_DB_OPTIONS,\n      ...dbOptions,\n    },\n    auth: {\n      ...DEFAULT_AUTH_OPTIONS,\n      ...authOptions,\n    },\n    realtime: {\n      ...DEFAULT_REALTIME_OPTIONS,\n      ...realtimeOptions,\n    },\n    global: {\n      ...DEFAULT_GLOBAL_OPTIONS,\n      ...globalOptions,\n    },\n  }\n}\n", "import { FunctionsClient } from '@supabase/functions-js'\nimport { AuthChangeEvent } from '@supabase/gotrue-js'\nimport {\n  PostgrestClient,\n  PostgrestFilterBuilder,\n  PostgrestQueryBuilder,\n} from '@supabase/postgrest-js'\nimport {\n  RealtimeChannel,\n  RealtimeChannelOptions,\n  RealtimeClient,\n  RealtimeClientOptions,\n} from '@supabase/realtime-js'\nimport { StorageClient as SupabaseStorageClient } from '@supabase/storage-js'\nimport { DEFAULT_HEADERS } from './lib/constants'\nimport { fetchWithAuth } from './lib/fetch'\nimport { stripTrailingSlash, applySettingDefaults } from './lib/helpers'\nimport { SupabaseAuthClient } from './lib/SupabaseAuthClient'\nimport { Fetch, GenericSchema, SupabaseClientOptions, SupabaseAuthClientOptions } from './lib/types'\n\nconst DEFAULT_GLOBAL_OPTIONS = {\n  headers: DEFAULT_HEADERS,\n}\n\nconst DEFAULT_DB_OPTIONS = {\n  schema: 'public',\n}\n\nconst DEFAULT_AUTH_OPTIONS: SupabaseAuthClientOptions = {\n  autoRefreshToken: true,\n  persistSession: true,\n  detectSessionInUrl: true,\n  flowType: 'implicit',\n}\n\nconst DEFAULT_REALTIME_OPTIONS: RealtimeClientOptions = {}\n\n/**\n * Supabase Client.\n *\n * An isomorphic Javascript client for interacting with Postgres.\n */\nexport default class SupabaseClient<\n  Database = any,\n  SchemaName extends string & keyof Database = 'public' extends keyof Database\n    ? 'public'\n    : string & keyof Database,\n  Schema extends GenericSchema = Database[SchemaName] extends GenericSchema\n    ? Database[SchemaName]\n    : any\n> {\n  /**\n   * Supabase Auth allows you to create and manage user sessions for access to data that is secured by access policies.\n   */\n  auth: SupabaseAuthClient\n  realtime: RealtimeClient\n\n  protected realtimeUrl: string\n  protected authUrl: string\n  protected storageUrl: string\n  protected functionsUrl: string\n  protected rest: PostgrestClient<Database, SchemaName>\n  protected storageKey: string\n  protected fetch?: Fetch\n  protected changedAccessToken?: string\n\n  protected headers: {\n    [key: string]: string\n  }\n\n  /**\n   * Create a new client for use in the browser.\n   * @param supabaseUrl The unique Supabase URL which is supplied when you create a new project in your project dashboard.\n   * @param supabaseKey The unique Supabase Key which is supplied when you create a new project in your project dashboard.\n   * @param options.db.schema You can switch in between schemas. The schema needs to be on the list of exposed schemas inside Supabase.\n   * @param options.auth.autoRefreshToken Set to \"true\" if you want to automatically refresh the token before expiring.\n   * @param options.auth.persistSession Set to \"true\" if you want to automatically save the user session into local storage.\n   * @param options.auth.detectSessionInUrl Set to \"true\" if you want to automatically detects OAuth grants in the URL and signs in the user.\n   * @param options.realtime Options passed along to realtime-js constructor.\n   * @param options.global.fetch A custom fetch implementation.\n   * @param options.global.headers Any additional headers to send with each network request.\n   */\n  constructor(\n    protected supabaseUrl: string,\n    protected supabaseKey: string,\n    options?: SupabaseClientOptions<SchemaName>\n  ) {\n    if (!supabaseUrl) throw new Error('supabaseUrl is required.')\n    if (!supabaseKey) throw new Error('supabaseKey is required.')\n\n    const _supabaseUrl = stripTrailingSlash(supabaseUrl)\n\n    this.realtimeUrl = `${_supabaseUrl}/realtime/v1`.replace(/^http/i, 'ws')\n    this.authUrl = `${_supabaseUrl}/auth/v1`\n    this.storageUrl = `${_supabaseUrl}/storage/v1`\n    this.functionsUrl = `${_supabaseUrl}/functions/v1`\n\n    // default storage key uses the supabase project ref as a namespace\n    const defaultStorageKey = `sb-${new URL(this.authUrl).hostname.split('.')[0]}-auth-token`\n    const DEFAULTS = {\n      db: DEFAULT_DB_OPTIONS,\n      realtime: DEFAULT_REALTIME_OPTIONS,\n      auth: { ...DEFAULT_AUTH_OPTIONS, storageKey: defaultStorageKey },\n      global: DEFAULT_GLOBAL_OPTIONS,\n    }\n\n    const settings = applySettingDefaults(options ?? {}, DEFAULTS)\n\n    this.storageKey = settings.auth?.storageKey ?? ''\n    this.headers = settings.global?.headers ?? {}\n\n    this.auth = this._initSupabaseAuthClient(\n      settings.auth ?? {},\n      this.headers,\n      settings.global?.fetch\n    )\n    this.fetch = fetchWithAuth(supabaseKey, this._getAccessToken.bind(this), settings.global?.fetch)\n\n    this.realtime = this._initRealtimeClient({ headers: this.headers, ...settings.realtime })\n    this.rest = new PostgrestClient(`${_supabaseUrl}/rest/v1`, {\n      headers: this.headers,\n      schema: settings.db?.schema,\n      fetch: this.fetch,\n    })\n\n    this._listenForAuthEvents()\n  }\n\n  /**\n   * Supabase Functions allows you to deploy and invoke edge functions.\n   */\n  get functions() {\n    return new FunctionsClient(this.functionsUrl, {\n      headers: this.headers,\n      customFetch: this.fetch,\n    })\n  }\n\n  /**\n   * Supabase Storage allows you to manage user-generated content, such as photos or videos.\n   */\n  get storage() {\n    return new SupabaseStorageClient(this.storageUrl, this.headers, this.fetch)\n  }\n\n  from<\n    TableName extends string & keyof Schema['Tables'],\n    Table extends Schema['Tables'][TableName]\n  >(relation: TableName): PostgrestQueryBuilder<Schema, Table>\n  from<ViewName extends string & keyof Schema['Views'], View extends Schema['Views'][ViewName]>(\n    relation: ViewName\n  ): PostgrestQueryBuilder<Schema, View>\n  from(relation: string): PostgrestQueryBuilder<Schema, any>\n  /**\n   * Perform a query on a table or a view.\n   *\n   * @param relation - The table or view name to query\n   */\n  from(relation: string): PostgrestQueryBuilder<Schema, any> {\n    return this.rest.from(relation)\n  }\n\n  /**\n   * Perform a function call.\n   *\n   * @param fn - The function name to call\n   * @param args - The arguments to pass to the function call\n   * @param options - Named parameters\n   * @param options.head - When set to `true`, `data` will not be returned.\n   * Useful if you only need the count.\n   * @param options.count - Count algorithm to use to count rows returned by the\n   * function. Only applicable for [set-returning\n   * functions](https://www.postgresql.org/docs/current/functions-srf.html).\n   *\n   * `\"exact\"`: Exact but slow count algorithm. Performs a `COUNT(*)` under the\n   * hood.\n   *\n   * `\"planned\"`: Approximated but fast count algorithm. Uses the Postgres\n   * statistics under the hood.\n   *\n   * `\"estimated\"`: Uses exact count for low numbers and planned count for high\n   * numbers.\n   */\n  rpc<\n    FunctionName extends string & keyof Schema['Functions'],\n    Function_ extends Schema['Functions'][FunctionName]\n  >(\n    fn: FunctionName,\n    args: Function_['Args'] = {},\n    options?: {\n      head?: boolean\n      count?: 'exact' | 'planned' | 'estimated'\n    }\n  ): PostgrestFilterBuilder<\n    Schema,\n    Function_['Returns'] extends any[]\n      ? Function_['Returns'][number] extends Record<string, unknown>\n        ? Function_['Returns'][number]\n        : never\n      : never,\n    Function_['Returns']\n  > {\n    return this.rest.rpc(fn, args, options)\n  }\n\n  /**\n   * Creates a Realtime channel with Broadcast, Presence, and Postgres Changes.\n   *\n   * @param {string} name - The name of the Realtime channel.\n   * @param {Object} opts - The options to pass to the Realtime channel.\n   *\n   */\n  channel(name: string, opts: RealtimeChannelOptions = { config: {} }): RealtimeChannel {\n    return this.realtime.channel(name, opts)\n  }\n\n  /**\n   * Returns all Realtime channels.\n   */\n  getChannels(): RealtimeChannel[] {\n    return this.realtime.getChannels()\n  }\n\n  /**\n   * Unsubscribes and removes Realtime channel from Realtime client.\n   *\n   * @param {RealtimeChannel} channel - The name of the Realtime channel.\n   *\n   */\n  removeChannel(channel: RealtimeChannel): Promise<'ok' | 'timed out' | 'error'> {\n    return this.realtime.removeChannel(channel)\n  }\n\n  /**\n   * Unsubscribes and removes all Realtime channels from Realtime client.\n   */\n  removeAllChannels(): Promise<('ok' | 'timed out' | 'error')[]> {\n    return this.realtime.removeAllChannels()\n  }\n\n  private async _getAccessToken() {\n    const { data } = await this.auth.getSession()\n\n    return data.session?.access_token ?? null\n  }\n\n  private _initSupabaseAuthClient(\n    {\n      autoRefreshToken,\n      persistSession,\n      detectSessionInUrl,\n      storage,\n      storageKey,\n      flowType,\n      debug,\n    }: SupabaseAuthClientOptions,\n    headers?: Record<string, string>,\n    fetch?: Fetch\n  ) {\n    const authHeaders = {\n      Authorization: `Bearer ${this.supabaseKey}`,\n      apikey: `${this.supabaseKey}`,\n    }\n    return new SupabaseAuthClient({\n      url: this.authUrl,\n      headers: { ...authHeaders, ...headers },\n      storageKey: storageKey,\n      autoRefreshToken,\n      persistSession,\n      detectSessionInUrl,\n      storage,\n      flowType,\n      debug,\n      fetch,\n    })\n  }\n\n  private _initRealtimeClient(options: RealtimeClientOptions) {\n    return new RealtimeClient(this.realtimeUrl, {\n      ...options,\n      params: { ...{ apikey: this.supabaseKey }, ...options?.params },\n    })\n  }\n\n  private _listenForAuthEvents() {\n    let data = this.auth.onAuthStateChange((event, session) => {\n      this._handleTokenChanged(event, 'CLIENT', session?.access_token)\n    })\n    return data\n  }\n\n  private _handleTokenChanged(\n    event: AuthChangeEvent,\n    source: 'CLIENT' | 'STORAGE',\n    token?: string\n  ) {\n    if (\n      (event === 'TOKEN_REFRESHED' || event === 'SIGNED_IN') &&\n      this.changedAccessToken !== token\n    ) {\n      // Token has changed\n      this.realtime.setAuth(token ?? null)\n\n      this.changedAccessToken = token\n    } else if (event === 'SIGNED_OUT') {\n      // Token is removed\n      this.realtime.setAuth(this.supabaseKey)\n      if (source == 'STORAGE') this.auth.signOut()\n      this.changedAccessToken = undefined\n    }\n  }\n}\n", "import SupabaseClient from './SupabaseClient'\nimport type { GenericSchema, SupabaseClientOptions } from './lib/types'\n\nexport * from '@supabase/gotrue-js'\nexport type { User as AuthUser, Session as AuthSession } from '@supabase/gotrue-js'\nexport type {\n  PostgrestResponse,\n  PostgrestSingleResponse,\n  PostgrestMaybeSingleResponse,\n  PostgrestError,\n} from '@supabase/postgrest-js'\nexport {\n  FunctionsHttpError,\n  FunctionsFetchError,\n  FunctionsRelayError,\n  FunctionsError,\n} from '@supabase/functions-js'\nexport * from '@supabase/realtime-js'\nexport { default as SupabaseClient } from './SupabaseClient'\nexport type { SupabaseClientOptions } from './lib/types'\n\n/**\n * Creates a new Supabase Client.\n */\nexport const createClient = <\n  Database = any,\n  SchemaName extends string & keyof Database = 'public' extends keyof Database\n    ? 'public'\n    : string & keyof Database,\n  Schema extends GenericSchema = Database[SchemaName] extends GenericSchema\n    ? Database[SchemaName]\n    : any\n>(\n  supabaseUrl: string,\n  supabaseKey: string,\n  options?: SupabaseClientOptions<SchemaName>\n): SupabaseClient<Database, SchemaName, Schema> => {\n  return new SupabaseClient(supabaseUrl, supabaseKey, options)\n}\n"],
  "mappings": "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",
  "names": ["PostgrestError", "PostgrestBuilder", "res", "PostgrestTransformBuilder", "PostgrestFilterBuilder", "PostgrestQueryBuilder", "fetch", "head", "PostgrestClient", "fetch", "head", "get", "fetch", "FunctionRegion", "index", "WebSocket", "SOCKET_STATES", "CHANNEL_STATES", "CHANNEL_EVENTS", "TRANSPORTS", "CONNECTION_STATE", "PostgresTypes", "REALTIME_PRESENCE_LISTEN_EVENTS", "REALTIME_POSTGRES_CHANGES_LISTEN_EVENT", "REALTIME_LISTEN_TYPES", "REALTIME_SUBSCRIBE_STATES", "postgres_changes", "_a", "_b", "type", "noop", "fetch", "WebSocket", "resolveFetch", "fetch", "__awaiter", "__awaiter", "fetch", "resolveFetch", "version", "version", "fetch", "resolveFetch", "fetch", "version", "DEFAULT_HEADERS", "version", "resolveFetch", "crossFetch", "CrossFetchHeaders", "fetch", "__awaiter", "DEFAULT_DB_OPTIONS", "DEFAULT_AUTH_OPTIONS", "DEFAULT_REALTIME_OPTIONS", "DEFAULT_GLOBAL_OPTIONS", "DEFAULT_HEADERS", "fetch"]
}
